<?xml version="1.0"?>
<doc>
    <assembly>
        <name>VNLib.Utils</name>
    </assembly>
    <members>
        <member name="T:VNLib.Utils.Async.AccessSerializer`2">
            <summary>
            Provides access arbitration to an exclusive resouce
            </summary>
            <typeparam name="TKey">The uinique identifier type for the resource</typeparam>
            <typeparam name="TResource">The resource type</typeparam>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`2.#ctor(System.Func{`0,`1},System.Action)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Async.AccessSerializer`2"/> with the specified factory and completed callback
            </summary>
            <param name="factory">Factory function to genereate new <typeparamref name="TResource"/> objects from <typeparamref name="TKey"/> keys</param>
            <param name="completedCb">Function to be invoked when the encapsulated objected is no longer in use</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`2.TryWait(`0,System.TimeSpan,VNLib.Utils.ExclusiveResourceHandle{`1}@)">
            <summary>
            Attempts to obtain an exclusive lock on the object 
            </summary>
            <param name="key"></param>
            <param name="wait">Time to wait for lock</param>
            <param name="exObj"></param>
            <returns>true if lock was obtained within the timeout, false if the lock was not obtained</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`2.Wait(`0)">
            <summary>
            Waits for exclusive access to the resource.
            </summary>
            <param name="key"></param>
            <returns>An <see cref="T:VNLib.Utils.ExclusiveResourceHandle`1"/> encapsulating the resource</returns>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`2.WaitAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for exclusive access to the resource.
            </summary>
            <returns>An <see cref="T:VNLib.Utils.ExclusiveResourceHandle`1"/> encapsulating the resource</returns>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`2.Release">
            <summary>
            Releases an exclusive lock that is held on an object
            </summary>
        </member>
        <member name="T:VNLib.Utils.Async.AccessSerializer`3">
            <summary>
            Provides access arbitration to an <see cref="T:VNLib.Utils.IExclusiveResource"/>
            </summary>
            <typeparam name="TKey">The uinique identifier type for the resource</typeparam>
            <typeparam name="TArg">The type of the optional argument to be passed to the user-implemented factory function</typeparam>
            <typeparam name="TResource">The resource type</typeparam>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`3.#ctor(System.Func{`0,`1,`2},System.Action)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Async.AccessSerializer`3"/> with the specified factory and completed callback
            </summary>
            <param name="factory">Factory function to genereate new <typeparamref name="TResource"/> objects from <typeparamref name="TKey"/> keys</param>
            <param name="completedCb">Function to be invoked when the encapsulated objected is no longer in use</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`3.TryWait(`0,`1,System.TimeSpan,VNLib.Utils.ExclusiveResourceHandle{`2}@)">
            <summary>
            Attempts to obtain an exclusive lock on the object 
            </summary>
            <param name="key"></param>
            <param name="arg">The key identifying the resource</param>
            <param name="wait">Time to wait for lock</param>
            <param name="exObj"></param>
            <returns>true if lock was obtained within the timeout, false if the lock was not obtained</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`3.Wait(`0,`1)">
            <summary>
            Waits for exclusive access to the resource.
            </summary>
            <param name="key">The unique key that identifies the resource</param>
            <param name="arg">The state argument to pass to the factory function</param>
            <returns>An <see cref="T:VNLib.Utils.ExclusiveResourceHandle`1"/> encapsulating the resource</returns>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`3.WaitAsync(`0,`1,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for exclusive access to the resource.
            </summary>
            <param name="key"></param>
            <param name="arg">The state argument to pass to the factory function</param>
            <param name="cancellationToken"></param>
            <returns>An <see cref="T:VNLib.Utils.ExclusiveResourceHandle`1"/> encapsulating the resource</returns>
        </member>
        <member name="M:VNLib.Utils.Async.AccessSerializer`3.Release">
            <summary>
            Releases an exclusive lock that is held on an object
            </summary>
        </member>
        <member name="T:VNLib.Utils.Async.AsyncExclusiveResource`1">
            <summary>
            Provides a base class for resources that must be obtained exclusivly in a multi-threaded environment
            but allow state update operations (and their exceptions) to be deferred to the next accessor.
            </summary>
            <typeparam name="TState">The state parameter type passed during updates</typeparam>
        </member>
        <member name="F:VNLib.Utils.Async.AsyncExclusiveResource`1.MainLock">
            <summary>
            Main mutli-threading lock used for primary access synchronization
            </summary>
        </member>
        <member name="P:VNLib.Utils.Async.AsyncExclusiveResource`1.IsDisposed">
            <summary>
            A value indicating whether the resource is disposed 
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncExclusiveResource`1.WaitOne(System.Int32)">
            <summary>
            <inheritdoc/>
            <br></br>
            <br></br>
            If the previous call to <see cref="M:VNLib.Utils.Async.AsyncExclusiveResource`1.UpdateAndRelease(System.Boolean,`0)"/> resulted in an asynchronous update, and exceptions occured, an <see cref="T:VNLib.Utils.Async.AsyncUpdateException"/>
            will be thrown enclosing the exception
            </summary>
            <param name="millisecondsTimeout">Time in milliseconds to wait for exclusive access to the resource</param>
            <exception cref="T:VNLib.Utils.Async.AsyncUpdateException"></exception>
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncExclusiveResource`1.UpdateAndRelease(System.Boolean,`0)">
            <summary>
            Requests a resource update and releases the exclusive lock on this resource. If a deferred update operation has any 
            exceptions during its last operation, they will be thrown here.  
            </summary>
            <param name="defer">Specifies weather the update should be deferred or awaited on the current call</param>
            <param name="state">A state parameter to be pased to the update function</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncExclusiveResource`1.UpdateResource(`0,System.Boolean)">
             <summary>
             When overrriden in a derived class, is responsible for updating the state of the instance if necessary.
             <br></br> 
             <br></br>
             If the result of the update retruns a <see cref="T:System.Threading.Tasks.Task"/> that represents an async update, the next call to <see cref="M:VNLib.Utils.Async.AsyncExclusiveResource`1.WaitOne(System.Int32)"/> will 
             block until the operation completes and will throw any exceptions that occured
             <br></br>
             <br></br>
             This function should return <see cref="P:System.Threading.Tasks.Task.CompletedTask"/> if the operation completed synchronously
            </summary>
             <param name="state">State parameter passed when releasing</param>
             <param name="defer">true if the caller expects a resource update to run asynchronously, false if the caller expects the result of the update to be awaited</param>
             <returns>A <see cref="T:System.Threading.Tasks.Task"/> representing the async state update operation, or null if no async state update operation need's to be monitored</returns>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncExclusiveResource`1.WaitOneAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncExclusiveResource`1.DisposeAsync">
            <summary>
            Waits for a pending update to complete, if incomplete
            and cleans held resources
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that represents the async operation </returns>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncExclusiveResource`1.Check">
            <summary>
            Determines if the resource is disposed
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:VNLib.Utils.Async.AsyncExclusiveResource">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="T:VNLib.Utils.Async.AsyncQueue`1">
            <summary>
            Provides a <see cref="T:System.Threading.Channels.Channel`1"/> based asynchronous queue
            </summary>
            <typeparam name="T">The event object type</typeparam>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.#ctor(System.Int32)">
            <summary>
            Initalizes a new multi-threaded bound channel queue, that accepts 
            the <paramref name="capacity"/> number of items before it will 
            return asynchronously, or fail to enqueue items
            </summary>
            <param name="capacity">The maxium number of items to allow in the queue</param>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.#ctor">
            <summary>
            Initalizes a new multi-threaded unbound channel queue
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.#ctor(System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Initalizes a new queue that allows specifying concurrency requirements 
            and a bound/unbound channel capacity
            </summary>
            <param name="singleWriter">A value that specifies only a single thread be enqueing items?</param>
            <param name="singleReader">A value that specifies only a single thread will be dequeing</param>
            <param name="capacity">The maxium number of items to enque without failing</param>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.#ctor(System.Threading.Channels.UnboundedChannelOptions)">
            <summary>
            Initalizes a new unbound channel based queue
            </summary>
            <param name="ubOptions">Channel options</param>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.#ctor(System.Threading.Channels.BoundedChannelOptions)">
            <summary>
            Initalizes a new bound channel based queue
            </summary>
            <param name="options">Channel options</param>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.TryEnque(`0)">
            <summary>
            Attemts to enqeue an item if the queue has the capacity
            </summary>
            <param name="item">The item to eqneue</param>
            <returns>True if the queue can accept another item, false otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.EnqueueAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Enqueues an item to the end of the queue and notifies a waiter that an item was enqueued
            </summary>
            <param name="item">The item to enqueue</param>
            <param name="cancellationToken"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.DequeueAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits for an item to be Enqueued to the end of the queue.
            </summary>
            <returns>The item at the begining of the queue</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.TryDequeue(`0@)">
            <summary>
            Removes the object at the beginning of the queue and stores it to the result parameter. Without waiting for a change 
            event. 
            </summary>
            <param name="result">The item that was at the begining of the queue</param>
            <returns>True if the queue could be read synchronously, false if the lock could not be entered, or the queue contains no items</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncQueue`1.TryPeek(`0@)">
            <summary>
            Peeks the object at the beginning of the queue and stores it to the result parameter. Without waiting for a change 
            event. 
            </summary>
            <param name="result">The item that was at the begining of the queue</param>
            <returns>True if the queue could be read synchronously, false if the lock could not be entered, or the queue contains no items</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:VNLib.Utils.Async.AsyncUpdateCallback">
            <summary>
            A callback delegate used for updating a <see cref="T:VNLib.Utils.Async.AsyncUpdatableResource"/>
            </summary>
            <param name="source">The <see cref="T:VNLib.Utils.Async.AsyncUpdatableResource"/> to be updated</param>
            <param name="data">The serialized data to be stored/updated</param>
            <exception cref="T:VNLib.Utils.ResourceUpdateFailedException"></exception>
        </member>
        <member name="T:VNLib.Utils.Async.AsyncDeleteCallback">
            <summary>
            A callback delegate invoked when a <see cref="T:VNLib.Utils.Async.AsyncUpdatableResource"/> delete is requested
            </summary>
            <param name="source">The <see cref="T:VNLib.Utils.Async.AsyncUpdatableResource"/> to be deleted</param>
            <exception cref="T:VNLib.Utils.ResourceDeleteFailedException"></exception>
        </member>
        <member name="T:VNLib.Utils.Async.AsyncUpdatableResource">
            <summary>
            Implemented by a resource that is backed by an external data store, that when modified or deleted will 
            be reflected to the backing store.
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncUpdatableResource.InitializeAsync(VNLib.Utils.Async.AsyncUpdateCallback,VNLib.Utils.Async.AsyncDeleteCallback,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Inializes the callback functions and serializer options to use when serialzing the state data
            </summary>
            <param name="updateCallback">The function to invoke when the resource has been modified and need to be updated</param>
            <param name="deletedCallback">The function to invoke when the resource should be deleted</param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> to use when serializing resource</param>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncUpdatableResource.ReleaseAsync">
            <summary>
            Releases the resource and flushes pending changes to its backing store.
            </summary>
            <returns>A task that represents the async operation</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:VNLib.Utils.ResourceDeleteFailedException"></exception>
            <exception cref="T:VNLib.Utils.ResourceUpdateFailedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncUpdatableResource.FlushPendingChangesAsync">
            <summary>
            <para>
            Writes the current state of the the resource to the backing store
            immediatly by invoking the specified callback. 
            </para>
            <para>
            Only call this method if your store supports multiple state updates
            </para>
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncUpdatableResource.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Async.AsyncUpdateException">
            <summary>
            Represents an exception that was raised during an asyncronous update of a resource. The <see cref="P:System.Exception.InnerException"/> stores the 
            details of the actual exception raised
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.AsyncUpdateException.#ctor(System.Exception)">
            <summary>
            
            </summary>
            <param name="inner"></param>
        </member>
        <member name="T:VNLib.Utils.Async.IAsyncExclusiveResource">
            <summary>
            <inheritdoc/>
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.IAsyncExclusiveResource.ReleaseAsync">
            <summary>
            Releases the resource from use. Called when a <see cref="T:VNLib.Utils.ExclusiveResourceHandle`1"/> is disposed
            </summary>
        </member>
        <member name="T:VNLib.Utils.Async.IAsyncWaitHandle">
            <summary>
            Provides a synchronization handle that can be asynchronously aquired
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.IAsyncWaitHandle.WaitOneAsync(System.Threading.CancellationToken)">
            <summary>
            Waits for exclusive access to the resource until the <see cref="T:System.Threading.CancellationToken"/> expires
            </summary>
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Async.IWaitHandle">
            <summary>
            Provides basic thread synchronization functions similar to <see cref="T:System.Threading.WaitHandle"/>
            </summary>
        </member>
        <member name="M:VNLib.Utils.Async.IWaitHandle.WaitOne">
            <summary>
            Waits for exclusive access to the resource indefinitly. If the signal is never received this method never returns
            </summary>
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns>true if the current thread received the signal</returns>
        </member>
        <member name="M:VNLib.Utils.Async.IWaitHandle.WaitOne(System.Int32)">
            <summary>
            Waits for exclusive access to the resource until the specified number of milliseconds
            </summary>
            <param name="millisecondsTimeout">Time in milliseconds to wait for exclusive access to the resource</param>
            <returns>true if the current thread received the signal, false if the timout expired, and access was not granted</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Async.IWaitHandle.WaitOne(System.TimeSpan)">
            <summary>
            Waits for exclusive access to the resource until the specified <see cref="T:System.TimeSpan"/>
            </summary>
            <returns>true if the current thread received the signal, false if the timout expired, and access was not granted</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:VNLib.Utils.BitField">
            <summary>
            Represents a field of 64 bits that can be set or cleared using unsigned or signed masks
            </summary>
        </member>
        <member name="P:VNLib.Utils.BitField.Value">
            <summary>
            The readonly value of the <see cref="T:VNLib.Utils.BitField"/>
            </summary>
        </member>
        <member name="M:VNLib.Utils.BitField.#ctor(System.UInt64)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.BitField"/> initialized to the specified value
            </summary>
            <param name="initial">Initial value</param>
        </member>
        <member name="M:VNLib.Utils.BitField.#ctor(System.Int64)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.BitField"/> initialized to the specified value
            </summary>
            <param name="initial">Initial value</param>
        </member>
        <member name="M:VNLib.Utils.BitField.IsSet(System.UInt64)">
            <summary>
            Determines if the specified flag is set
            </summary>
            <param name="mask">The mask to compare against the field value</param>
            <returns>True if the flag(s) is currently set, false if flag is not set</returns>
        </member>
        <member name="M:VNLib.Utils.BitField.IsSet(System.Int64)">
            <summary>
            Determines if the specified flag is set
            </summary>
            <param name="mask">The mask to compare against the field value</param>
            <returns>True if the flag(s) is currently set, false if flag is not set</returns>
        </member>
        <member name="M:VNLib.Utils.BitField.Set(System.UInt64)">
            <summary>
            Determines if the specified flag is set
            </summary>
            <param name="mask">The mask to compare against the field value</param>
            <returns>True if the flag(s) is currently set, false if flag is not set</returns>
        </member>
        <member name="M:VNLib.Utils.BitField.Set(System.Int64)">
            <summary>
            Determines if the specified flag is set
            </summary>
            <param name="mask">The mask to compare against the field value</param>
            <returns>True if the flag(s) is currently set, false if flag is not set</returns>
        </member>
        <member name="M:VNLib.Utils.BitField.Set(System.UInt64,System.Boolean)">
            <summary>
            Sets or clears a flag(s) indentified by a mask based on the value
            </summary>
            <param name="mask">Mask used to identify flags</param>
            <param name="value">True to set a flag, false to clear a flag</param>
        </member>
        <member name="M:VNLib.Utils.BitField.Clear(System.UInt64)">
            <summary>
            Clears the flag identified by the specified mask
            </summary>
            <param name="mask">The mask used to clear the given flag</param>
        </member>
        <member name="M:VNLib.Utils.BitField.Clear(System.Int64)">
            <summary>
            Clears the flag identified by the specified mask
            </summary>
            <param name="mask">The mask used to clear the given flag</param>
        </member>
        <member name="M:VNLib.Utils.BitField.ClearAll">
            <summary>
            Clears all flags by setting the <see cref="F:VNLib.Utils.BitField.Field"/> property value to 0
            </summary>
        </member>
        <member name="T:VNLib.Utils.CallbackOpenHandle">
            <summary>
            A concrete <see cref="T:VNLib.Utils.OpenHandle"/> for a defered operation or a resource that should be released or unwound
            when the instance lifetime has ended.
            </summary>
        </member>
        <member name="M:VNLib.Utils.CallbackOpenHandle.#ctor(System.Action)">
            <summary>
            Creates a new generic <see cref="T:VNLib.Utils.OpenHandle"/> with the specified release callback method
            </summary>
            <param name="release">The callback function to invoke when the <see cref="T:VNLib.Utils.OpenHandle"/> is disposed</param>
        </member>
        <member name="M:VNLib.Utils.CallbackOpenHandle.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.CallbackOpenResourceHandle`1">
            <summary>
            A concrete class that defines an <see cref="T:VNLib.Utils.OpenResourceHandle`1"/> where the release actions
            require unknown or unstructured events or operations that can happen in a callback delegate
            </summary>
        </member>
        <member name="M:VNLib.Utils.CallbackOpenResourceHandle`1.#ctor(System.Action,`0)">
            <summary>
            Creates a new generic with the specified release callback method
            </summary>
            <param name="release">The callback function to invoke when the <see cref="T:VNLib.Utils.CallbackOpenResourceHandle`1"/> is disposed</param>
            <param name="resource"></param>
        </member>
        <member name="M:VNLib.Utils.CallbackOpenResourceHandle`1.#ctor(System.Action{`0},`0)">
            <summary>
            Creates a new generic <see cref="T:VNLib.Utils.CallbackOpenResourceHandle`1"/> with the specified release callback method
            </summary>
            <param name="release">The callback function to invoke when the <see cref="T:VNLib.Utils.CallbackOpenResourceHandle`1"/> is disposed</param>
            <param name="resource"></param>
        </member>
        <member name="P:VNLib.Utils.CallbackOpenResourceHandle`1.Resource">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.CallbackOpenResourceHandle`1.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.ERRNO">
            <summary>
            Implements a C style integer error code type. Size is platform dependent
            </summary>
        </member>
        <member name="F:VNLib.Utils.ERRNO.SUCCESS">
            <summary>
            Represents a successfull error code (true)
            </summary>
        </member>
        <member name="F:VNLib.Utils.ERRNO.E_FAIL">
            <summary>
            Represents a failure error code (false)
            </summary>
        </member>
        <member name="M:VNLib.Utils.ERRNO.#ctor(System.IntPtr)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.ERRNO"/> from the specified error value
            </summary>
            <param name="errno">The value of the error to represent</param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Implicit(System.Int32)~VNLib.Utils.ERRNO">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.ERRNO"/> from an <see cref="T:System.Int32"/> error code. null = 0 = false
            </summary>
            <param name="errorVal">Error code</param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Explicit(System.Nullable{System.Int32})~VNLib.Utils.ERRNO">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.ERRNO"/> from an <see cref="T:System.Int32"/> error code. null = 0 = false
            </summary>
            <param name="errorVal">Error code</param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Implicit(System.Boolean)~VNLib.Utils.ERRNO">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.ERRNO"/> from a booleam, 1 if true, 0 if false
            </summary>
            <param name="errorVal"></param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Implicit(System.IntPtr)~VNLib.Utils.ERRNO">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.ERRNO"/> from a pointer value
            </summary>
            <param name="errno">The pointer value representing an error code</param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Implicit(VNLib.Utils.ERRNO)~System.Int32">
            <summary>
            Error value as integer. Value of supplied error code or if cast from boolean 1 if true, 0 if false
            </summary>
            <param name="errorVal"><see cref="T:VNLib.Utils.ERRNO"/> to get error code from</param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Implicit(VNLib.Utils.ERRNO)~System.Boolean">
            <summary>
            C style boolean conversion. false if 0, true otherwise 
            </summary>
            <param name="errorVal"></param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Implicit(VNLib.Utils.ERRNO)~System.IntPtr">
            <summary>
            Creates a new <see cref="T:System.IntPtr"/> from the value if the stored (nint) error code 
            </summary>
            <param name="errno">The <see cref="T:VNLib.Utils.ERRNO"/> contating the pointer value</param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.op_Implicit(VNLib.Utils.ERRNO)~System.IntPtr">
            <summary>
            Creates a new <c>nint</c> from the value if the stored error code 
            </summary>
            <param name="errno">The <see cref="T:VNLib.Utils.ERRNO"/> contating the pointer value</param>
        </member>
        <member name="M:VNLib.Utils.ERRNO.ToString">
            <summary>
            The integer error value of the current instance in radix 10
            </summary>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.ERRNO.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.ERRNO.ToString(System.String,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.ExclusiveResourceHandle`1">
            <summary>
            While in scope, holds an exclusive lock on the specified object that implements the <see cref="T:VNLib.Utils.IExclusiveResource"/> interface
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:VNLib.Utils.ExclusiveResourceHandle`1.Resource">
            <summary>
            <inheritdoc/>
            <br></br>
            <br></br>
            This value is lazy inialized and will invoke the factory function on first access.
            Accessing this variable is thread safe while the handle is in scope
            <br></br>
            <br></br>
            Exceptions will be propagated during initialziation
            </summary>
        </member>
        <member name="M:VNLib.Utils.ExclusiveResourceHandle`1.#ctor(System.Func{`0},System.Action)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.ExclusiveResourceHandle`1"/> wrapping the 
            <see cref="T:VNLib.Utils.IExclusiveResource"/> object to manage its lifecycle and reuse
            </summary>
            <param name="factory">Factory function that will generate the value when used</param>
            <param name="release">Callback function that will be invoked after object gets disposed</param>
        </member>
        <member name="T:VNLib.Utils.Extensions.CacheExtensions">
            <summary>
            Cache collection extensions
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.StoreRecord``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            <para>
            Stores a new record. If an old record exists, the records are compared, 
            if they are not equal, the old record is evicted and the new record is stored
            </para>
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T">A cachable object</typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record</param>
            <param name="record">The record to store</param>
            <remarks>
            Locks on the store parameter to provide mutual exclusion for non thread-safe 
            data structures.
            </remarks>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.StoreRecord``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,System.TimeSpan)">
            <summary>
            <para>
            Stores a new record and updates the expiration date. If an old record exists, the records
            are compared, if they are not equal, the old record is evicted and the new record is stored
            </para>
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T">A cachable object</typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record</param>
            <param name="record">The record to store</param>
            <param name="validFor">The new expiration time of the record</param>
            <remarks>
            Locks on the store parameter to provide mutual exclusion for non thread-safe 
            data structures.
            </remarks>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.TryGetOrEvictRecord``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1@)">
            <summary>
            <para>
            Returns a stored record if it exists and is not expired. If the record exists
            but has expired, it is evicted.
            </para>
            <para>
            If a record is evicted, the return value evaluates to -1 and the value parameter
            is set to the old record if the caller wished to inspect the record after the 
            eviction method completes
            </para>
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T">A cachable object</typeparam>
            <param name="store"></param>
            <param name="key"></param>
            <param name="value">The record</param>
            <returns>
            Gets a value indicating the reults of the operation. 0 if the record is not found, -1 if expired, 1 if 
            record is valid
            </returns>
            <remarks>
            Locks on the store parameter to provide mutual exclusion for non thread-safe 
            data structures.
            </remarks>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.UpdateRecord``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.TimeSpan)">
            <summary>
            Updates the expiration date on a record to the specified time if it exists, regardless 
            of its validity
            </summary>
            <typeparam name="K">Diction key type</typeparam>
            <typeparam name="T">A cachable object</typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record to update</param>
            <param name="extendedTime">The expiration time (time added to <see cref="P:System.DateTime.UtcNow"/>)</param>
            <remarks>
            Locks on the store parameter to provide mutual exclusion for non thread-safe 
            data structures.
            </remarks>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.EvictRecord``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            Evicts a stored record from the store. If the record is found, the eviction 
            method is executed
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record</param>
            <returns>True if the record was found and evicted</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.CollectRecords``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Evicts all expired records from the store
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.CollectRecords``2(System.Collections.Generic.IDictionary{``0,``1},System.DateTime)">
            <summary>
            Evicts all expired records from the store
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="store"></param>
            <param name="validAfter">A time that specifies the time which expired records should be evicted</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.UseRecord``3(System.Collections.Generic.IDictionary{``0,``1},``0,``2,System.Action{``1,``2})">
            <summary>
            Allows for mutually exclusive use of a <see cref="T:VNLib.Utils.Memory.Caching.ICacheable"/> record with a 
            state parameter
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="State"></typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record</param>
            <param name="state">A user-token type state parameter to pass to the use callback method</param>
            <param name="useCtx">A callback method that will be passed the record to use within an exclusive context</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.UseRecord``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Action{``1})">
            <summary>
            Allows for mutually exclusive use of a <see cref="T:VNLib.Utils.Memory.Caching.ICacheable"/> 
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record</param>
            <param name="useCtx">A callback method that will be passed the record to use within an exclusive context</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.UseIfValid``3(System.Collections.Generic.IDictionary{``0,``1},``0,``2,System.Action{``1,``2})">
            <summary>
            Allows for mutually exclusive use of a <see cref="T:VNLib.Utils.Memory.Caching.ICacheable"/> record with a 
            state parameter, only if the found record is valid
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <typeparam name="State"></typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record</param>
            <param name="state">A user-token type state parameter to pass to the use callback method</param>
            <param name="useCtx">A callback method that will be passed the record to use within an exclusive context</param>
            <remarks>If the record is found, but is expired, the record is evicted from the store. The callback is never invoked</remarks>
        </member>
        <member name="M:VNLib.Utils.Extensions.CacheExtensions.UseIfValid``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Action{``1})">
            <summary>
            Allows for mutually exclusive use of a <see cref="T:VNLib.Utils.Memory.Caching.ICacheable"/> record with a 
            state parameter, only if the found record is valid
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="store"></param>
            <param name="key">The unique key identifying the record</param>
            <param name="useCtx">A callback method that will be passed the record to use within an exclusive context</param>
            <remarks>If the record is found, but is expired, the record is evicted from the store. The callback is never invoked</remarks>
        </member>
        <member name="T:VNLib.Utils.Extensions.CollectionExtensions">
            <summary>
            Provides collection extension methods
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.CollectionExtensions.Sort``1(VNLib.Utils.Memory.VnList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the elements within the list by the specified <see cref="T:System.Collections.Generic.IComparer`1"/>
            instance
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer">The comparer used to sort the items within the list</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.CollectionExtensions.GetValueType``2(VNLib.Utils.IIndexable{``0,System.String},``0)">
            <summary>
            Gets a previously-stored base32 encoded value-type from the lookup and returns its initialized structure from
            the value stored
            </summary>
            <typeparam name="TKey">The key type used to index the lookup</typeparam>
            <typeparam name="TValue">An unmanaged structure type</typeparam>
            <param name="lookup"></param>
            <param name="key">The key used to identify the value</param>
            <returns>The initialized structure, or default if the lookup returns null/empty string</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.CollectionExtensions.SetValueType``2(VNLib.Utils.IIndexable{``0,System.String},``0,``1)">
            <summary>
            Serializes a value-type in base32 encoding and stores it at the specified key
            </summary>
            <typeparam name="TKey">The key type used to index the lookup</typeparam>
            <typeparam name="TValue">An unmanaged structure type</typeparam>
            <param name="lookup"></param>
            <param name="key">The key used to identify the value</param>
            <param name="value">The value to serialze</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.CollectionExtensions.TryForeach``1(System.Collections.Generic.IList{``0},System.Action{``0})">
            <summary>
            Executes a handler delegate on every element of the list within a try-catch block
            and rethrows exceptions as an <see cref="T:System.AggregateException"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="handler">An <see cref="T:System.Action"/> handler delegate to complete some operation on the elements within the list</param>
            <exception cref="T:System.AggregateException"></exception>
        </member>
        <member name="T:VNLib.Utils.Extensions.IoExtensions">
            <summary>
            Provieds extension methods for common IO operations
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.Unlock(System.IO.FileStream)">
            <summary>
            Unlocks the entire file
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.Lock(System.IO.FileStream)">
            <summary>
            Locks the entire file
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.CopyToAsync(System.IO.Stream,System.IO.Stream,System.Int32,VNLib.Utils.Memory.IUnmangedHeap,System.Threading.CancellationToken)">
            <summary>
            Provides an async wrapper for copying data from the current stream to another using an unmanged 
            buffer.
            </summary>
            <param name="source"></param>
            <param name="dest">The destination data stream to write data to</param>
            <param name="bufferSize">The size of the buffer to use while copying data. (Value will be clamped to the size of the stream if seeking is available)</param>
            <param name="heap">The <see cref="T:VNLib.Utils.Memory.IUnmangedHeap"/> to allocate the buffer from</param>
            <param name="token">A token that may cancel asynchronous operations</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that completes when the copy operation has completed</returns>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.CopyToAsync(System.IO.Stream,System.IO.Stream,System.Int64,System.Int32,VNLib.Utils.Memory.IUnmangedHeap,System.Threading.CancellationToken)">
            <summary>
            Provides an async wrapper for copying data from the current stream to another with a 
            buffer from the <paramref name="heap"/>
            </summary>
            <param name="source"></param>
            <param name="dest">The destination data stream to write data to</param>
            <param name="bufferSize">The size of the buffer to use while copying data. (Value will be clamped to the size of the stream if seeking is available)</param>
            <param name="count">The number of bytes to copy from the current stream to destination stream</param>
            <param name="heap">The heap to alloc buffer from</param>
            <param name="token">A token that may cancel asynchronous operations</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that completes when the copy operation has completed</returns>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.CopyTo(System.IO.Stream,System.IO.Stream,VNLib.Utils.Memory.IUnmangedHeap)">
            <summary>
            Copies data from one stream to another, using self managed buffers. May allocate up to 2MB.
            </summary>
            <param name="source">Source stream to read from</param>
            <param name="dest">Destination stream to write data to</param>
            <param name="heap">The heap to allocate buffers from</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Int64,VNLib.Utils.Memory.IUnmangedHeap)">
            <summary>
            Copies data from one stream to another, using self managed buffers. May allocate up to 2MB.
            </summary>
            <param name="source">Source stream to read from</param>
            <param name="dest">Destination stream to write data to</param>
            <param name="count">Number of bytes to read/write</param>
            <param name="heap">The heap to allocate buffers from</param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.CopyToAsync(System.IO.Stream,System.IO.Stream,System.Memory{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Copies data from the current stream to the destination stream using the supplied memory buffer
            </summary>
            <param name="source"></param>
            <param name="dest">The destination data stream to write data to</param>
            <param name="buffer">The buffer to use when copying data</param>
            <param name="token">A token that may cancel asynchronous operations</param>
             <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that completes when the copy operation has completed</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.CopyToAsync(System.IO.Stream,System.IO.Stream,System.Memory{System.Byte},System.Int64,System.Threading.CancellationToken)">
            <summary>
            Copies data from the current stream to the destination stream using the supplied memory buffer
            </summary>
            <param name="source"></param>
            <param name="dest">The destination data stream to write data to</param>
            <param name="buffer">The buffer to use when copying data</param>
            <param name="count">The number of bytes to copy from the current stream to destination stream</param>
            <param name="token">A token that may cancel asynchronous operations</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that completes when the copy operation has completed</returns>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.OpenFile(System.IO.DirectoryInfo,System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
            <summary>
            Opens a file within the current directory
            </summary>
            <param name="dir"></param>
            <param name="fileName">The name of the file to open</param>
            <param name="mode">The <see cref="T:System.IO.FileMode"/> to open the file with</param>
            <param name="access">The <see cref="T:System.IO.FileAccess"/> to open the file with</param>
            <param name="share"></param>
            <param name="bufferSize">The size of the buffer to read/write with</param>
            <param name="options"></param>
            <returns>The <see cref="T:System.IO.FileStream"/> of the opened file</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.DeleteFile(System.IO.DirectoryInfo,System.String)">
            <summary>
            Deletes the speicifed file from the current directory
            </summary>
            <param name="dir"></param>
            <param name="fileName">The name of the file to delete</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.IoExtensions.FileExists(System.IO.DirectoryInfo,System.String)">
            <summary>
            Determines if a file exists within the current directory
            </summary>
            <param name="dir"></param>
            <param name="fileName">The name of the file to search for</param>
            <returns>True if the file is found and the user has permission to access the file, false otherwise</returns>
        </member>
        <member name="T:VNLib.Utils.Extensions.TimeParseType">
            <summary>
            Specifies how to parse a timespan value from a <see cref="T:System.Text.Json.JsonDocument"/> element
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.AsJsonObject``1(System.String,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Converts a JSON encoded string to an object of the specified type
            </summary>
            <typeparam name="T">Output type of the object</typeparam>
            <param name="value"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> to use during de-serialization</param>
            <returns>The new object or default if the string is null or empty</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.AsJsonObject``1(System.ReadOnlySpan{System.Byte}@,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Converts a JSON encoded binary data to an object of the specified type
            </summary>
            <typeparam name="T">Output type of the object</typeparam>
            <param name="utf8bin"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> to use during de-serialization</param>
            <returns>The new object or default if the string is null or empty</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.AsJsonObject``1(System.ReadOnlyMemory{System.Byte}@,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Converts a JSON encoded binary data to an object of the specified type
            </summary>
            <typeparam name="T">Output type of the object</typeparam>
            <param name="utf8bin"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> to use during de-serialization</param>
            <returns>The new object or default if the string is null or empty</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.AsJsonObject``1(System.Byte[],System.Text.Json.JsonSerializerOptions)">
            <summary>
            Converts a JSON encoded binary data to an object of the specified type
            </summary>
            <typeparam name="T">Output type of the object</typeparam>
            <param name="utf8bin"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> to use during de-serialization</param>
            <returns>The new object or default if the string is null or empty</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.AsJsonDocument(System.String,System.Text.Json.JsonDocumentOptions)">
            <summary>
            Parses a json encoded string to a json documen
            </summary>
            <param name="jsonString"></param>
            <param name="options"></param>
            <returns>If the json string is null, returns null, otherwise the json document around the data</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.GetPropString(System.Text.Json.JsonElement@,System.String)">
            <summary>
            Shortcut extension to <see cref="M:System.Text.Json.JsonElement.GetProperty(System.String)"/> and returns a string 
            </summary>
            <param name="element"></param>
            <param name="propertyName">The name of the property to get the string value of</param>
            <returns>If the property exists, returns the string stored at that property</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.GetPropString(System.Collections.Generic.IReadOnlyDictionary{System.String,System.Text.Json.JsonElement},System.String)">
            <summary>
            Shortcut extension to <see cref="M:System.Text.Json.JsonElement.GetProperty(System.String)"/> and returns a string 
            </summary>
            <param name="conf"></param>
            <param name="propertyName">The name of the property to get the string value of</param>
            <returns>If the property exists, returns the string stored at that property</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.GetPropString(System.Collections.Generic.IDictionary{System.String,System.Text.Json.JsonElement},System.String)">
            <summary>
            Shortcut extension to <see cref="M:System.Text.Json.JsonElement.GetProperty(System.String)"/> and returns a string 
            </summary>
            <param name="conf"></param>
            <param name="propertyName">The name of the property to get the string value of</param>
            <returns>If the property exists, returns the string stored at that property</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.ToJsonString``1(``0,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Attemts to serialze an object to a JSON encoded string
            </summary>
            <param name="obj"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> to use during serialization</param>
            <returns>A JSON encoded string of the serialized object, or null if the object is null</returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.Merge(System.Text.Json.JsonDocument,System.Text.Json.JsonDocument,System.String,System.String)">
            <summary>
            Merges the current <see cref="T:System.Text.Json.JsonDocument"/> with another <see cref="T:System.Text.Json.JsonDocument"/> to 
            create a new document of combined properties
            </summary>
            <param name="initial"></param>
            <param name="other">The <see cref="T:System.Text.Json.JsonDocument"/> to combine with the first document</param>
            <param name="initalName">The name of the new element containing the initial document data</param>
            <param name="secondName">The name of the new element containing the additional document data</param>
            <returns>A new document with a parent root containing the combined objects</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.JsonExtensions.GetTimeSpan(System.Text.Json.JsonElement@,VNLib.Utils.Extensions.TimeParseType)">
            <summary>
            Parses a number value into a <see cref="T:System.TimeSpan"/> of the specified time
            </summary>
            <param name="el"></param>
            <param name="type">The <see cref="T:VNLib.Utils.Extensions.TimeParseType"/> the value represents</param>
            <returns>The <see cref="T:System.TimeSpan"/> of the value</returns>
            <exception cref="T:System.FormatException"></exception>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:VNLib.Utils.Extensions.MemoryExtensions">
            <summary>
            Provides memory based extensions to .NET and VNLib memory abstractions
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Lease``1(System.Buffers.ArrayPool{``0},System.Int32,System.Boolean)">
            <summary>
            Rents a new array and stores it as a resource within an <see cref="T:VNLib.Utils.OpenResourceHandle`1"/> to return the 
            array when work is completed
            </summary>
            <typeparam name="T"></typeparam>
            <param name="pool"></param>
            <param name="size">The minimum size array to allocate</param>
            <param name="zero">Should elements from 0 to size be set to default(T)</param>
            <returns>A new <see cref="T:VNLib.Utils.OpenResourceHandle`1"/> encapsulating the rented array</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Rent``1(System.Buffers.ArrayPool{``0},System.Int32,System.Boolean)">
            <summary>
            Retreives a buffer that is at least the reqested length, and clears the array from 0-size. 
            <br></br>
            The array may be larger than the requested size, the data outside of the size paramter is not cleared
            </summary>
            <param name="pool"></param>
            <param name="size">The minimum length of the array</param>
            <param name="zero">True if contents should be zeroed</param>
            <returns>The zeroed array</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.ToString``1(``0)">
            <summary>
            Copies the characters within the memory handle to a <see cref="T:System.String"/>
            </summary>
            <returns>The string representation of the buffer</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.ToMemory``1(VNLib.Utils.Memory.MemoryHandle{``0})">
            <summary>
            Wraps the <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/> instance in System.Buffers.MemoryManager 
            wrapper to provide <see cref="T:System.Memory`1"/> buffers from umanaged handles.
            </summary>
            <typeparam name="T">The unmanaged data type</typeparam>
            <returns>The <see cref="T:System.Buffers.MemoryManager`1"/> wrapper</returns>
            <remarks>NOTE: This wrapper now manages the lifetime of the current handle</remarks>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.DirectAlloc``1(VNLib.Utils.Memory.IUnmangedHeap,System.UInt64,System.Boolean)">
            <summary>
            Allows direct allocation of a fixed size <see cref="T:System.Buffers.MemoryManager`1"/> from a <see cref="T:VNLib.Utils.Memory.PrivateHeap"/> instance
            of the specified number of elements
            </summary>
            <typeparam name="T">The unmanaged data type</typeparam>
            <param name="heap"></param>
            <param name="size">The number of elements to allocate on the heap</param>
            <param name="zero">Optionally zeros conents of the block when allocated</param>
            <returns>The <see cref="T:System.Buffers.MemoryManager`1"/> wrapper around the block of memory</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.DirectAlloc``1(VNLib.Utils.Memory.IUnmangedHeap,System.Int64,System.Boolean)">
            <summary>
            Allows direct allocation of a fixed size <see cref="T:System.Buffers.MemoryManager`1"/> from a <see cref="T:VNLib.Utils.Memory.PrivateHeap"/> instance
            of the specified number of elements
            </summary>
            <typeparam name="T">The unmanaged data type</typeparam>
            <param name="heap"></param>
            <param name="size">The number of elements to allocate on the heap</param>
            <param name="zero">Optionally zeros conents of the block when allocated</param>
            <returns>The <see cref="T:System.Buffers.MemoryManager`1"/> wrapper around the block of memory</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetOffset``1(VNLib.Utils.Memory.MemoryHandle{``0},System.Int64)">
            <summary>
            Gets an offset pointer from the base postion to the number of bytes specified. Performs bounds checks
            </summary>
            <param name="memory"></param>
            <param name="elements">Number of elements of type to offset</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns><typeparamref name="T"/> pointer to the memory offset specified</returns>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Resize``1(VNLib.Utils.Memory.MemoryHandle{``0},System.Int64)">
            <summary>
            Resizes the current handle on the heap
            </summary>
            <param name="memory"></param>
            <param name="elements">Positive number of elemnts the current handle should referrence</param>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.ResizeIfSmaller``1(VNLib.Utils.Memory.MemoryHandle{``0},System.Int64)">
            <summary>
            Resizes the target handle only if the handle is smaller than the requested element count
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handle"></param>
            <param name="count">The number of elements to resize to</param>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.ResizeIfSmaller``1(VNLib.Utils.Memory.MemoryHandle{``0},System.UInt64)">
            <summary>
            Resizes the target handle only if the handle is smaller than the requested element count
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handle"></param>
            <param name="count">The number of elements to resize to</param>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetOffsetSpan``1(VNLib.Utils.Memory.MemoryHandle{``0},System.UInt64,System.Int32)">
            <summary>
            Gets a 64bit friendly span offset for the current <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="block"></param>
            <param name="offset">The offset (in elements) from the begining of the block</param>
            <param name="size">The size of the block (in elements)</param>
            <returns>The offset span</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetOffsetSpan``1(VNLib.Utils.Memory.MemoryHandle{``0},System.Int64,System.Int32)">
            <summary>
            Gets a 64bit friendly span offset for the current <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="block"></param>
            <param name="offset">The offset (in elements) from the begining of the block</param>
            <param name="size">The size of the block (in elements)</param>
            <returns>The offset span</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetSubSequence``1(VNLib.Utils.Memory.MemoryHandle{``0},System.UInt64,System.Int32)">
            <summary>
            Gets a <see cref="T:VNLib.Utils.Memory.SubSequence`1"/> window within the current block
            </summary>
            <typeparam name="T"></typeparam>
            <param name="block"></param>
            <param name="offset">An offset within the handle</param>
            <param name="size">The size of the window</param>
            <returns>The new <see cref="T:VNLib.Utils.Memory.SubSequence`1"/> within the block</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.ToPool``1(VNLib.Utils.Memory.IUnmangedHeap)">
            <summary>
            Wraps the current instance with a <see cref="T:System.Buffers.MemoryPool`1"/> wrapper
            to allow System.Memory buffer rentals.
            </summary>
            <typeparam name="T">The unmanged data type to provide allocations from</typeparam>
            <returns>The new <see cref="T:System.Buffers.MemoryPool`1"/> heap wrapper.</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.StructAlloc``1(VNLib.Utils.Memory.IUnmangedHeap)">
            <summary>
            Allocates a structure of the specified type on the current unmanged heap and zero's its memory
            </summary>
            <typeparam name="T">The structure type</typeparam>
            <param name="heap"></param>
            <returns>A pointer to the structure ready for use.</returns>
            <remarks>Allocations must be freed with <see cref="M:VNLib.Utils.Extensions.MemoryExtensions.StructFree``1(VNLib.Utils.Memory.IUnmangedHeap,``0*)"/></remarks>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.StructFree``1(VNLib.Utils.Memory.IUnmangedHeap,``0*)">
            <summary>
            Frees a structure at the specified address from the this heap. 
            This must be the same heap the structure was allocated from
            </summary>
            <typeparam name="T">The structure type</typeparam>
            <param name="heap"></param>
            <param name="structPtr">A pointer to the structure</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Alloc``1(VNLib.Utils.Memory.IUnmangedHeap,System.UInt64,System.Boolean)">
            <summary>
            Allocates a block of unmanaged memory of the number of elements to store of an unmanged type
            </summary>
            <typeparam name="T">Unmanaged data type to create a block of</typeparam>
            <param name="heap"></param>
            <param name="elements">The size of the block (number of elements)</param>
            <param name="zero">A flag that zeros the allocated block before returned</param>
            <returns>The unmanaged <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/></returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Alloc``1(VNLib.Utils.Memory.IUnmangedHeap,System.Int64,System.Boolean)">
            <summary>
            Allocates a block of unmanaged memory of the number of elements to store of an unmanged type
            </summary>
            <typeparam name="T">Unmanaged data type to create a block of</typeparam>
            <param name="heap"></param>
            <param name="elements">The size of the block (number of elements)</param>
            <param name="zero">A flag that zeros the allocated block before returned</param>
            <returns>The unmanaged <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/></returns>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.AllocAndCopy``1(VNLib.Utils.Memory.IUnmangedHeap,System.ReadOnlySpan{``0})">
            <summary>
            Allocates a buffer from the current heap and initialzies it by copying the initial data buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="heap"></param>
            <param name="initialData">The initial data to set the buffer to</param>
            <returns>The initalized <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/> block</returns>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.WriteAndResize``1(VNLib.Utils.Memory.MemoryHandle{``0},System.ReadOnlySpan{``0})">
            <summary>
            Copies data from the input buffer to the current handle and resizes the handle to the 
            size of the buffer
            </summary>
            <typeparam name="T">The unamanged value type</typeparam>
            <param name="handle"></param>
            <param name="input">The input buffer to copy data from</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.UnsafeAlloc``1(VNLib.Utils.Memory.IUnmangedHeap,System.Int32,System.Boolean)">
            <summary>
            Allocates a block of unamanged memory of the number of elements of an unmanaged type, and 
            returns the <see cref="T:VNLib.Utils.Memory.UnsafeMemoryHandle`1"/> that must be used cautiously
            </summary>
            <typeparam name="T">The unamanged value type</typeparam>
            <param name="heap">The heap to allocate block from</param>
            <param name="elements">The number of elements to allocate</param>
            <param name="zero">A flag to zero the initial contents of the buffer</param>
            <returns>The allocated handle of the specified number of elements</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append(VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.Boolean)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append(VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.Int16)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append(VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.UInt16)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append(VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.Int32)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append(VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.UInt32)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append(VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.Int64)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append(VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.UInt64)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Append``1(VNLib.Utils.Memory.VnBufferWriter{System.Char}@,``0,System.ReadOnlySpan{System.Char},System.IFormatProvider)">
            <summary>
            Formats and appends the value to end of the buffer
            </summary>
            <param name="buffer"></param>
            <param name="value">The value to format and append to the buffer</param>
            <param name="format">An optional format argument</param>
            <param name="formatProvider"></param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetBytes(System.Text.Encoder,System.Char[],System.Int32,System.Int32,VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.Boolean)">
            <summary>
            Encodes a set of characters in the input characters span and any characters
            in the internal buffer into a sequence of bytes that are stored in the input
            byte span. A parameter indicates whether to clear the internal state of the 
            encoder after the conversion.
            </summary>
            <param name="enc"></param>
            <param name="chars">Character buffer to encode</param>
            <param name="offset">The offset in the char buffer to begin encoding chars from</param>
            <param name="charCount">The number of characers to encode</param>
            <param name="writer">The buffer writer to use</param>
            <param name="flush">true to clear the internal state of the encoder after the conversion; otherwise, false.</param>
            <returns>The actual number of bytes written at the location indicated by the bytes parameter.</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetBytes(System.Text.Encoder,System.ReadOnlySpan{System.Char},VNLib.Utils.Memory.VnBufferWriter{System.Byte}@,System.Boolean)">
            <summary>
            Encodes a set of characters in the input characters span and any characters
            in the internal buffer into a sequence of bytes that are stored in the input
            byte span. A parameter indicates whether to clear the internal state of the 
            encoder after the conversion.
            </summary>
            <param name="enc"></param>
            <param name="chars">The character buffer to encode</param>
            <param name="writer">The buffer writer to use</param>
            <param name="flush">true to clear the internal state of the encoder after the conversion; otherwise, false.</param>
            <returns>The actual number of bytes written at the location indicated by the bytes parameter.</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetBytes(System.Text.Encoding,System.ReadOnlySpan{System.Char},VNLib.Utils.Memory.VnBufferWriter{System.Byte}@)">
            <summary>
            Encodes a set of characters in the input characters span and any characters
            in the internal buffer into a sequence of bytes that are stored in the input
            byte span.
            </summary>
            <param name="encoding"></param>
            <param name="chars">The character buffer to encode</param>
            <param name="writer">The buffer writer to use</param>
            <returns>The actual number of bytes written at the location indicated by the bytes parameter.</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.GetChars(System.Text.Encoding,System.ReadOnlySpan{System.Byte},VNLib.Utils.Memory.VnBufferWriter{System.Char}@)">
            <summary>
            Decodes a character buffer in the input characters span and any characters
            in the internal buffer into a sequence of bytes that are stored in the input
            byte span.
            </summary>
            <param name="encoding"></param>
            <param name="bytes">The binary buffer to decode</param>
            <param name="writer">The buffer writer to use</param>
            <returns>The actual number of *characters* written at the location indicated by the chars parameter.</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.ToPrivate(VNLib.Utils.Memory.VnBufferWriter{System.Char}@)">
            <summary>
            Converts the buffer data to a <see cref="T:VNLib.Utils.Memory.PrivateString"/>
            </summary>
            <returns>A <see cref="T:VNLib.Utils.Memory.PrivateString"/> instance that owns the underlying string memory</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.AsSpan``1(VNLib.Utils.Memory.VnBufferWriter{``0}@)">
            <summary>
            Gets a <see cref="T:System.Span`1"/> over the modified section of the internal buffer
            </summary>
            <returns>A <see cref="T:System.Span`1"/> over the modified data</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Slice``1(``0[],System.Int32)">
            <summary>
            Slices the current array by the specified starting offset to the end 
            of the array
            </summary>
            <typeparam name="T">The array type</typeparam>
            <param name="arr"></param>
            <param name="start">The start offset of the new array slice</param>
            <returns>The sliced array</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.Slice``1(``0[],System.Int32,System.Int32)">
            <summary>
            Slices the current array by the specified starting offset to including the 
            speciifed number of items
            </summary>
            <typeparam name="T">The array type</typeparam>
            <param name="arr"></param>
            <param name="start">The start offset of the new array slice</param>
            <param name="count">The size of the new array</param>
            <returns>The sliced array</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.OverlappedShift``1(System.Span{``0}@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copies an overlapping memory range by shifting it 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="buffer"></param>
            <param name="start">The starting position of the data to copy from <paramref name="buffer"/></param>
            <param name="offset">The starting position within <paramref name="buffer"/> to write the block to</param>
            <param name="size">The size of the section to shift</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.AsSpan``1(VNLib.Utils.Memory.IMemoryHandle{``0},System.Int32)">
            <summary>
            Creates a new sub-sequence over the target handle. (allows for convient sub span)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handle"></param>
            <param name="start">Intial offset into the handle</param>
            <returns>The sub-sequence of the current handle</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.AsSpan``1(VNLib.Utils.Memory.IMemoryHandle{``0},System.Int32,System.Int32)">
            <summary>
            Creates a new sub-sequence over the target handle. (allows for convient sub span)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handle"></param>
            <param name="start">Intial offset into the handle</param>
            <param name="count">The number of elements within the new sequence</param>
            <returns>The sub-sequence of the current handle</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.AsSpan``1(VNLib.Utils.Memory.UnsafeMemoryHandle{``0}@,System.Int32)">
            <summary>
            Creates a new sub-sequence over the target handle. (allows for convient sub span)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handle"></param>
            <param name="start">Intial offset into the handle</param>
            <returns>The sub-sequence of the current handle</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.AsSpan``1(VNLib.Utils.Memory.UnsafeMemoryHandle{``0}@,System.Int32,System.Int32)">
            <summary>
            Creates a new sub-sequence over the target handle. (allows for convient sub span)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="handle"></param>
            <param name="start">Intial offset into the handle</param>
            <param name="count">The number of elements within the new sequence</param>
            <returns>The sub-sequence of the current handle</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.MemoryExtensions.ThrowIfClosed(System.Runtime.InteropServices.SafeHandle)">
            <summary>
            Raises an <see cref="T:System.ObjectDisposedException"/> if the current handle 
            has been disposed or set as invalid
            </summary>
            <param name="handle"></param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:VNLib.Utils.Extensions.MutexReleaser">
            <summary>
            Represents a releaser handle for a <see cref="T:System.Threading.Mutex"/>
            that has been entered and will be released. Best if used
            within a using() statment
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.MutexReleaser.Dispose">
            <summary>
             Releases the held System.Threading.Mutex once.
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.MutexReleaser.ReleaseMutext">
            <summary>
            Releases the held System.Threading.Mutex once.
            </summary>
        </member>
        <member name="T:VNLib.Utils.Extensions.SafeMethodNameAttribute">
            <summary>
            When applied to a delegate, specifies the name of the native method to load
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.SafeMethodNameAttribute.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Extensions.SafeMethodNameAttribute"/>
            </summary>
            <param name="nativeMethodName">The name of the native method</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.SafeMethodNameAttribute.#ctor">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Extensions.SafeMethodNameAttribute"/>, that uses the 
            delegate name as the native method name
            </summary>
        </member>
        <member name="P:VNLib.Utils.Extensions.SafeMethodNameAttribute.MethodName">
            <summary>
            The name of the native method
            </summary>
        </member>
        <member name="T:VNLib.Utils.Extensions.SafeLibraryExtensions">
            <summary>
            Contains native library extension methods
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.SafeLibraryExtensions.GetMethod``1(VNLib.Utils.SafeLibraryHandle)">
            <summary>
            Loads a native method from the current <see cref="T:VNLib.Utils.SafeLibraryHandle"/>
            that has a <see cref="T:VNLib.Utils.Extensions.SafeMethodNameAttribute"/> 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="library"></param>
            <returns></returns>
            <exception cref="T:System.MissingMemberException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.EntryPointNotFoundException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.SafeLibraryExtensions.DangerousGetMethod``1(VNLib.Utils.SafeLibraryHandle)">
            <summary>
            Loads a native method from the current <see cref="T:VNLib.Utils.SafeLibraryHandle"/>
            that has a <see cref="T:VNLib.Utils.Extensions.SafeMethodNameAttribute"/> 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="library"></param>
            <returns></returns>
            <exception cref="T:System.MissingMemberException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.EntryPointNotFoundException"></exception>
            <remarks>
            The libraries handle count is left unmodified
            </remarks>
        </member>
        <member name="T:VNLib.Utils.Extensions.SemSlimReleaser">
            <summary>
            Represents a releaser handle for a <see cref="T:System.Threading.SemaphoreSlim"/>
            that has been entered and will be released. Best if used
            within a using() statment
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.SemSlimReleaser.Dispose">
            <summary>
            Releases the System.Threading.SemaphoreSlim object once.
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.SemSlimReleaser.Release">
            <summary>
            Releases the System.Threading.SemaphoreSlim object once.
            </summary>
            <returns>The previous count of the <see cref="T:System.Threading.SemaphoreSlim"/></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.Threading.SemaphoreFullException"></exception>
        </member>
        <member name="T:VNLib.Utils.Extensions.StringExtensions">
            <summary>
            Extention methods for string (character buffer)
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split``1(System.String,System.String,``0,System.StringSplitOptions)">
            <summary>
            Split a string based on split value and insert into the specified list
            </summary>
            <param name="value"></param>
            <param name="splitter">The value to split the string on</param>
            <param name="output">The list to output data to</param>
            <param name="options">String split options</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split``1(System.String,System.Char,``0,System.StringSplitOptions)">
            <summary>
            Split a string based on split value and insert into the specified list
            </summary>
            <param name="value"></param>
            <param name="splitter">The value to split the string on</param>
            <param name="output">The list to output data to</param>
            <param name="options">String split options</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split``1(System.String,System.ReadOnlySpan{System.Char},``0,System.StringSplitOptions)">
            <summary>
            Split a string based on split value and insert into the specified list
            </summary>
            <param name="value"></param>
            <param name="splitter">The value to split the string on</param>
            <param name="output">The list to output data to</param>
            <param name="options">String split options</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split``1(System.ReadOnlySpan{System.Char}@,System.Char,``0,System.StringSplitOptions)">
            <summary>
            Split a string based on split value and insert into the specified list
            </summary>
            <param name="value"></param>
            <param name="splitter">The value to split the string on</param>
            <param name="output">The list to output data to</param>
            <param name="options">String split options</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split``1(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char},``0,System.StringSplitOptions)">
            <summary>
            Split a <see cref="T:System.ReadOnlySpan`1"/> based on split value and insert into the specified list
            </summary>
            <param name="value"></param>
            <param name="splitter">The value to split the string on</param>
            <param name="output">The list to output data to</param>
            <param name="options">String split options</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split``1(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char},System.StringSplitOptions,System.Buffers.ReadOnlySpanAction{System.Char,``0},``0)">
            <summary>
            Split a <see cref="T:System.ReadOnlySpan`1"/> based on split value and pass it to the split delegate handler
            </summary>
            <param name="value"></param>
            <param name="splitter">The sequence to split the string on</param>
            <param name="options">String split options</param>
            <param name="splitCb">The action to invoke when a split segment has been found</param>
            <param name="state">The state to pass to the callback handler</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split``1(System.ReadOnlySpan{System.Char}@,System.Char,System.StringSplitOptions,System.Buffers.ReadOnlySpanAction{System.Char,``0},``0)">
            <summary>
            Split a <see cref="T:System.ReadOnlySpan`1"/> based on split value and pass it to the split delegate handler
            </summary>
            <param name="value"></param>
            <param name="splitter">The character to split the string on</param>
            <param name="options">String split options</param>
            <param name="splitCb">The action to invoke when a split segment has been found</param>
            <param name="state"></param>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char},System.StringSplitOptions,VNLib.Utils.Extensions.SpanSplitStatelessDelegate)">
            <summary>
            Split a <see cref="T:System.ReadOnlySpan`1"/> based on split value and pass it to the split delegate handler
            </summary>
            <param name="value"></param>
            <param name="splitter">The sequence to split the string on</param>
            <param name="options">String split options</param>
            <param name="splitCb">The action to invoke when a split segment has been found</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Split(System.ReadOnlySpan{System.Char}@,System.Char,System.StringSplitOptions,VNLib.Utils.Extensions.SpanSplitStatelessDelegate)">
            <summary>
            Split a <see cref="T:System.ReadOnlySpan`1"/> based on split value and pass it to the split delegate handler
            </summary>
            <param name="value"></param>
            <param name="splitter">The character to split the string on</param>
            <param name="options">String split options</param>
            <param name="splitCb">The action to invoke when a split segment has been found</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.EndOf(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Gets the index of the end of the found sequence
            </summary>
            <param name="data"></param>
            <param name="search">Sequence to search for within the current sequence</param>
            <returns>the index of the end of the sequenc</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.EndOf(System.ReadOnlySpan{System.Char}@,System.Char)">
            <summary>
            Gets the index of the end of the found character
            </summary>
            <param name="data"></param>
            <param name="search">Character to search for within the current sequence</param>
            <returns>the index of the end of the sequence</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.SliceBeforeParam(System.ReadOnlySpan{System.Char}@,System.Char)">
            <summary>
            Slices the current span from the begining of the segment to the first occurrance of the specified character. 
            If the character is not found, the entire segment is returned
            </summary>
            <param name="data"></param>
            <param name="search">The delimiting character</param>
            <returns>The segment of data before the search character, or the entire segment if not found</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.SliceBeforeParam(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Slices the current span from the begining of the segment to the first occurrance of the specified character sequence. 
            If the character sequence is not found, the entire segment is returned
            </summary>
            <param name="data"></param>
            <param name="search">The delimiting character sequence</param>
            <returns>The segment of data before the search character, or the entire <paramref name="data"/> if the seach sequence is not found</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.SliceAfterParam(System.ReadOnlySpan{System.Char}@,System.Char)">
            <summary>
            Gets the remaining segment of data after the specified search character or <see cref="P:System.ReadOnlySpan`1.Empty"/> 
            if the search character is not found within the current segment
            </summary>
            <param name="data"></param>
            <param name="search">The character to search for within the segment</param>
            <returns>The segment of data after the search character or <see cref="P:System.ReadOnlySpan`1.Empty"/> if not found</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.SliceAfterParam(System.ReadOnlySpan{System.Char}@,System.ReadOnlySpan{System.Char})">
            <summary>
            Gets the remaining segment of data after the specified search sequence or <see cref="P:System.ReadOnlySpan`1.Empty"/> 
            if the search sequence is not found within the current segment
            </summary>
            <param name="data"></param>
            <param name="search">The sequence to search for within the segment</param>
            <returns>The segment of data after the search sequence or <see cref="P:System.ReadOnlySpan`1.Empty"/> if not found</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.TrimCRLF(System.ReadOnlySpan{System.Char}@)">
            <summary>
            Trims any leading or trailing <c>'\r'|'\n'|' '</c>(whitespace) characters from the segment
            </summary>
            <returns>The trimmed segment</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Replace(System.Span{System.Char}@,System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Replaces a character sequence within the buffer 
            </summary>
            <param name="buffer">The character buffer to process</param>
            <param name="search">The sequence to search for</param>
            <param name="replace">The sequence to write in the place of the search parameter</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.Replace(VNLib.Utils.Memory.VnBufferWriter{System.Char}@,System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Replaces a character sequence within the writer 
            </summary>
            <param name="writer"></param>
            <param name="search">The sequence to search for</param>
            <param name="replace">The sequence to write in the place of the search parameter</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.StringExtensions.ReplaceInPlace(System.Span{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Replaces very ocurrance of character sequence within a buffer with another sequence of the same length
            </summary>
            <param name="buffer"></param>
            <param name="search">The sequence to search for</param>
            <param name="replace">The sequence to replace the found sequence with</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="T:VNLib.Utils.Extensions.ThreadingExtensions">
            <summary>
            Provides extension methods to common threading and TPL library operations
            </summary>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.EnterSafeContext``1(VNLib.Utils.OpenResourceHandle{``0},System.Action{``0})">
            <summary>
            Allows an <see cref="T:VNLib.Utils.OpenResourceHandle`1"/> to execute within a scope limited context
            </summary>
            <typeparam name="TResource">The resource type</typeparam>
            <param name="rh"></param>
            <param name="safeCallback">The function body that will execute with controlled access to the resource</param>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.GetReleaserAsync(System.Threading.SemaphoreSlim,System.Threading.CancellationToken)">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/> while observing a <see cref="T:System.Threading.CancellationToken"/>
            and getting a releaser handle
            </summary>
            <param name="semaphore"></param>
            <param name="cancellationToken">A token to cancel the operation</param>
            <returns>A releaser handle that may be disposed to release the semaphore</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.OperationCanceledException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.GetReleaserAsync(System.Threading.SemaphoreSlim,System.Int32)">
            <summary>
            Asynchronously waits to enter the <see cref="T:System.Threading.SemaphoreSlim"/> using a 32-bit signed integer to measure the time intervale
            and getting a releaser handle
            </summary>
            <param name="semaphore"></param>
            <param name="timeout">A the maximum amount of time in milliseconds to wait to enter the semaphore</param>
            <returns>A releaser handle that may be disposed to release the semaphore</returns>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.GetReleaser(System.Threading.SemaphoreSlim)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>
            </summary>
            <param name="semaphore"></param>
            <returns>A releaser handler that releases the semaphore when disposed</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.GetReleaser(System.Threading.SemaphoreSlim,System.Int32)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>
            </summary>
            <param name="semaphore"></param>
            <param name="timeout">A the maximum amount of time in milliseconds to wait to enter the semaphore</param>
            <returns>A releaser handler that releases the semaphore when disposed</returns>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.Enter(System.Threading.Mutex)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.Mutex"/>
            </summary>
            <param name="mutex"></param>
            <returns>A releaser handler that releases the semaphore when disposed</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.Threading.AbandonedMutexException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.Enter(System.Threading.Mutex,System.Int32)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:System.Threading.SemaphoreSlim"/>
            </summary>
            <param name="mutex"></param>
            <param name="timeout">A the maximum amount of time in milliseconds to wait to enter the semaphore</param>
            <returns>A releaser handler that releases the semaphore when disposed</returns>
            <exception cref="T:System.TimeoutException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.WaitAsync(System.Threading.WaitHandle,System.Int32)">
            <summary>
            Asynchronously waits for a the <see cref="T:System.Threading.WaitHandle"/> to receive a signal. This method spins until 
            a thread yield will occur, then asynchronously yields.
            </summary>
            <param name="handle"></param>
            <param name="timeoutMs">The timeout interval in milliseconds</param>
            <returns>
            A task that compeletes when the wait handle receives a signal or times-out,
            the result of the awaited task will be <c>true</c> if the signal is received, or 
            <c>false</c> if the timeout interval expires
            </returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.ThreadingExtensions.RegisterUnobserved(System.Threading.CancellationToken,System.Action)">
            <summary>
            Registers a callback method that will be called when the token has been cancelled.
            This method waits indefinitely for the token to be cancelled. 
            </summary>
            <param name="token"></param>
            <param name="callback">The callback method to invoke when the token has been cancelled</param>
            <returns>A task that may be unobserved, that completes when the token has been cancelled</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.TimerExtensions.Stop(System.Threading.Timer)">
            <summary>
            Attempts to stop the timer
            </summary>
            <returns>True if the timer was successfully modified, false otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.TimerExtensions.Stop(System.Threading.Timer,System.TimeSpan)">
            <summary>
            Attempts to stop an active timer and prepare a <see cref="T:VNLib.Utils.OpenHandle"/> configured to restore the state of the timer to the specified timespan
            </summary>
            <param name="timer"></param>
            <param name="resumeTime"><see cref="T:System.TimeSpan"/> representing the amount of time the timer should wait before invoking the callback function</param>
            <returns>A new <see cref="T:VNLib.Utils.OpenHandle"/> if the timer was stopped successfully that will resume the timer when closed, null otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.TimerExtensions.Restart(System.Threading.Timer,System.TimeSpan)">
            <summary>
            Attempts to reset and start a timer
            </summary>
            <param name="timer"></param>
            <param name="wait"><see cref="T:System.TimeSpan"/> to wait before the timer event is fired</param>
            <returns>True if the timer was successfully modified</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.TimerExtensions.Restart(System.Threading.Timer,System.Int32)">
            <summary>
            Attempts to reset and start a timer
            </summary>
            <param name="timer"></param>
            <param name="waitMilliseconds">Time in milliseconds to wait before the timer event is fired</param>
            <returns>True if the timer was successfully modified</returns>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.Conatins(VNLib.Utils.Memory.VnString,System.Char)">
            <summary>
            Derermines if the character exists within the instance
            </summary>
            <param name="str"></param>
            <param name="value">The value to find</param>
            <returns>True if the character exists within the instance</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.Conatins(VNLib.Utils.Memory.VnString,System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Derermines if the sequence exists within the instance
            </summary>
            <param name="str"></param>
            <param name="value">The sequence to find</param>
            <param name="stringComparison"></param>
            <returns>True if the character exists within the instance</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.IndexOf(VNLib.Utils.Memory.VnString,System.Char)">
            <summary>
             Searches for the first occurrance of the specified character within the current instance
            </summary>
            <param name="str"></param>
            <param name="value">The character to search for within the instance</param>
            <returns>The 0 based index of the occurance, -1 if the character was not found</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.IndexOf(VNLib.Utils.Memory.VnString,System.ReadOnlySpan{System.Char})">
            <summary>
            Searches for the first occurrance of the specified sequence within the current instance
            </summary>
            <param name="str"></param>
            <param name="search">The sequence to search for</param>
            <returns>The 0 based index of the occurance, -1 if the sequence was not found</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.IndexOf(VNLib.Utils.Memory.VnString,System.ReadOnlySpan{System.Char},System.StringComparison)">
            <summary>
            Searches for the first occurrance of the specified sequence within the current instance
            </summary>
            <param name="str"></param>
            <param name="search">The sequence to search for</param>
            <param name="comparison">The <see cref="T:System.StringComparison"/> type to use in searchr</param>
            <returns>The 0 based index of the occurance, -1 if the sequence was not found</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.IndexOf(VNLib.Utils.Memory.VnString,System.ReadOnlySpan{System.Char},System.Int32)">
            <summary>
            Searches for the 0 based index of the first occurance of the search parameter after the start index.
            </summary>
            <param name="str"></param>
            <param name="search">The sequence of data to search for</param>
            <param name="start">The lower boundry of the search area</param>
            <returns>The absolute index of the first occurrance within the instance, -1 if the sequency was not found in the windowed segment</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.EndOf(VNLib.Utils.Memory.VnString,System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the realtive index after the specified sequence within the <see cref="T:VNLib.Utils.Memory.VnString"/> instance
            </summary>
            <param name="str"></param>
            <param name="search">The sequence to search for</param>
            <returns>The index after the found sequence within the string, -1 if the sequence was not found within the instance</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.AbsoluteTrim(VNLib.Utils.Memory.VnString,System.Int32,System.Int32)">
            <summary>
            Allows for trimming whitespace characters in a realtive sequence from 
            within a <see cref="T:VNLib.Utils.Memory.VnString"/> buffer defined by the start and end parameters
            and returning the trimmed entry.
            </summary>
            <param name="data"></param>
            <param name="start">The starting position within the sequence to trim</param>
            <param name="end">The end of the sequence to trim</param>
            <returns>The trimmed <see cref="T:VNLib.Utils.Memory.VnString"/> instance as a child of the original entry</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.AbsoluteTrim(VNLib.Utils.Memory.VnString,System.Int32@,System.Int32@)">
            <summary>
            Finds whitespace characters within the sequence defined between start and end parameters 
            and adjusts the specified window to "trim" whitespace
            </summary>
            <param name="data"></param>
            <param name="start">The starting position within the sequence to trim</param>
            <param name="end">The end of the sequence to trim</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.AbsoluteTrim(VNLib.Utils.Memory.VnString,System.Int32)">
            <summary>
            Allows for trimming whitespace characters in a realtive sequence from 
            within a <see cref="T:VNLib.Utils.Memory.VnString"/> buffer and returning the trimmed entry.
            </summary>
            <param name="data"></param>
            <param name="start">The starting position within the sequence to trim</param>
            <returns>The trimmed <see cref="T:VNLib.Utils.Memory.VnString"/> instance as a child of the original entry</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.IndexOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.RelativeTirm(VNLib.Utils.Memory.VnString)">
            <summary>
            Trims leading or trailing whitespace characters and returns a new child instance 
            without leading or trailing whitespace
            </summary>
            <returns>A child <see cref="T:VNLib.Utils.Memory.VnString"/> of the current instance without leading or trailing whitespaced</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.Split(VNLib.Utils.Memory.VnString,System.ReadOnlyMemory{System.Char},System.StringSplitOptions)">
            <summary>
            Allows for enumeration of segments of data within the specified <see cref="T:VNLib.Utils.Memory.VnString"/> instance that are 
            split by the search parameter
            </summary>
            <param name="data"></param>
            <param name="search">The sequence of data to delimit segments</param>
            <param name="options">The options used to split the string instances</param>
            <returns>An iterator to enumerate the split segments</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.TrimCRLF(VNLib.Utils.Memory.VnString)">
            <summary>
            Trims any leading or trailing <c>'\r'|'\n'|' '</c>(whitespace) characters from the segment
            </summary>
            <returns>The trimmed segment</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.GetEnumerator(VNLib.Utils.Memory.VnString)">
            <summary>
            Unoptimized character enumerator. You should use <see cref="M:VNLib.Utils.Memory.VnString.AsSpan"/> to enumerate the unerlying data.
            </summary>
            <returns>The next character in the sequence</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.ToVnString(VNLib.Utils.Memory.MemoryHandle{System.Char},System.Int32)">
            <summary>
            Converts the current handle to a <see cref="T:VNLib.Utils.Memory.VnString"/>, a zero-alloc immutable wrapper 
            for a memory handle
            </summary>
            <param name="handle"></param>
            <param name="length">The number of characters from the handle to reference (length of the string)</param>
            <returns>The new <see cref="T:VNLib.Utils.Memory.VnString"/> wrapper</returns>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.ToVnString(VNLib.Utils.Memory.MemoryHandle{System.Char})">
            <summary>
            Converts the current handle to a <see cref="T:VNLib.Utils.Memory.VnString"/>, a zero-alloc immutable wrapper 
            for a memory handle
            </summary>
            <param name="handle"></param>
            <returns>The new <see cref="T:VNLib.Utils.Memory.VnString"/> wrapper</returns>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Extensions.VnStringExtensions.ToVnString(VNLib.Utils.Memory.MemoryHandle{System.Char},System.UInt64,System.Int32)">
            <summary>
            Converts the current handle to a <see cref="T:VNLib.Utils.Memory.VnString"/>, a zero-alloc immutable wrapper 
            for a memory handle
            </summary>
            <param name="handle"></param>
            <param name="offset">The offset in characters that represents the begining of the string</param>
            <param name="length">The number of characters from the handle to reference (length of the string)</param>
            <returns>The new <see cref="T:VNLib.Utils.Memory.VnString"/> wrapper</returns>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:VNLib.Utils.IExclusiveResource">
            <summary>
            An object, that when used in a mulithreading context, guaruntees that the caller has exclusive 
            access to the instance and relinquishes exclusive access when Release() is called;
            </summary>
        </member>
        <member name="P:VNLib.Utils.IExclusiveResource.IsReleased">
            <summary>
            Gets a value indicating if the resource has been released
            </summary>
        </member>
        <member name="M:VNLib.Utils.IExclusiveResource.Release">
            <summary>
            Releases the resource from use. Called when a <see cref="T:VNLib.Utils.ExclusiveResourceHandle`1"/> is disposed
            </summary>
        </member>
        <member name="T:VNLib.Utils.IIndexable`2">
            <summary>
            Provides an interface that provides an indexer
            </summary>
            <typeparam name="TKey">The lookup Key</typeparam>
            <typeparam name="TValue">The lookup value</typeparam>
        </member>
        <member name="P:VNLib.Utils.IIndexable`2.Item(`0)">
            <summary>
            Gets or sets the value at the specified index in the collection
            </summary>
            <param name="key">The key to lookup the value at</param>
            <returns>The value at the specified key</returns>
        </member>
        <member name="T:VNLib.Utils.IO.BackingStream`1">
            <summary>
            Provides basic stream support sync/async stream operations to a 
            backing stream with virtual event methods. Provides a pass-through 
            as best as possbile. 
            </summary>
        </member>
        <member name="F:VNLib.Utils.IO.BackingStream`1.BaseStream">
            <summary>
            The backing/underlying stream operations are being performed on
            </summary>
        </member>
        <member name="F:VNLib.Utils.IO.BackingStream`1.ForceReadOnly">
            <summary>
            A value that will cause all calls to write to throw <see cref="T:System.NotSupportedException"/>
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.BackingStream`1.CanRead">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.BackingStream`1.CanSeek">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.BackingStream`1.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.BackingStream`1.Length">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.BackingStream`1.WriteTimeout">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.BackingStream`1.ReadTimeout">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.BackingStream`1.Position">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.Flush">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.Read(System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.SetLength(System.Int64)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.Close">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.OnClose">
            <summary>
            Raised directly after the base stream is closed, when a call to close is made
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.OnFlush">
            <summary>
            Raised directly after the base stream is flushed, when a call to flush is made
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.OnWrite(System.Int32)">
            <summary>
            Raised directly after a successfull write operation.
            </summary>
            <param name="count">The number of bytes written to the stream</param>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.CopyTo(System.IO.Stream,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.BackingStream`1.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.IO.FileOperations">
            <summary>
            Contains cross-platform optimized filesystem operations.
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.FileOperations.FileExists(System.String)">
            <summary>
            Determines if a file exists. If application is current running in the Windows operating system, Shlwapi.PathFileExists is invoked,
            otherwise <see cref="M:System.IO.File.Exists(System.String)"/> is invoked
            </summary>
            <param name="filePath">the path to the file</param>
            <returns>True if the file can be opened, false otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.IO.FileOperations.GetAttributes(System.String)">
            <summary>
            If Windows is detected at load time, gets the attributes for the specified file.
            </summary>
            <param name="filePath">The path to the existing file</param>
            <returns>The attributes of the file </returns>
            <exception cref="T:System.IO.PathTooLongException"></exception>
            <exception cref="T:System.IO.FileNotFoundException"></exception>
            <exception cref="T:System.UnauthorizedAccessException"></exception>
        </member>
        <member name="T:VNLib.Utils.IO.InMemoryTemplate">
            <summary>
            Represents a lazily loaded file stored in memory, with a change mointor 
            that reloads the template if the file was modified in the filesystem
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.InMemoryTemplate.TemplateName">
            <summary>
            Gets the name of the template
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.InMemoryTemplate.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new in-memory copy of a file that will detect changes and refresh
            </summary>
            <param name="listenForChanges">Should changes to the template file be moniored for changes, and reloaded as necessary</param>
            <param name="path">The path of the file template</param>
        </member>
        <member name="M:VNLib.Utils.IO.InMemoryTemplate.GetTemplateData">
            <summary>
            Gets a cached copy of the template data
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.InMemoryTemplate.ReadFile">
            <summary>
            Updates the internal copy of the file to its memory representation
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.InMemoryTemplate.ReadFileAsync(System.Threading.CancellationToken)">
            <summary>
            Updates the internal copy of the file to its memory representation, asynchronously
            </summary>
            <param name="cancellationToken"></param>
            <returns>A task that completes when the file has been copied into memory</returns>
        </member>
        <member name="M:VNLib.Utils.IO.InMemoryTemplate.OnModifed">
            <summary>
            Invoked when the template file has been modifed. Note: This event is raised 
            while the <see cref="F:VNLib.Utils.IO.InMemoryTemplate.TemplateLock"/> is held.
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.InMemoryTemplate.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.IO.ISlindingWindowBuffer`1">
            <summary>
            Represents a sliding window buffer for reading/wiriting data
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.WindowStartPos">
            <summary>
            The starting positon of the available data within the buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.WindowEndPos">
            <summary>
            The ending position of the available data within the buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.Buffer">
            <summary>
            Buffer memory wrapper
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.ISlindingWindowBuffer`1.Close">
            <summary>
            Releases resources used by the current instance
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.Available">
            <summary>
            Gets the number of available items within the buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.CurrentWindowSpan">
            <summary>
            Gets a window within the buffer of available buffered data
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.CurrentWindow">
            <summary>
            Gets a window within the buffer of available buffered data
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.Remianing">
            <summary>
            Gets the number of available (remaining) buffer elements
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.ISlindingWindowBuffer`1.RemainingWindow">
            <summary>
            Gets the available buffer window to write data to
            </summary>
        </member>
        <member name="T:VNLib.Utils.IO.IsolatedStorageDirectory">
            <summary>
            Represents an open directory within an <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"/> store for which files can be created, opened, or deleted.
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.#ctor(System.IO.IsolatedStorage.IsolatedStorageFile,System.String)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.IO.IsolatedStorageDirectory"/> within the specified file using the directory name.
            </summary>
            <param name="storage">A configured and open <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"/></param>
            <param name="dir">The directory name to open or create within the store</param>
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.CreateFile(System.String)">
            <summary>
            Creates a file by its path name within the currnet directory
            </summary>
            <param name="fileName">The name of the file</param>
            <returns>The open file</returns>
            <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.IO.DirectoryNotFoundException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.DeleteFile(System.String)">
            <summary>
            Removes a file from the current directory 
            </summary>
            <param name="fileName">The path of the file to remove</param>
            <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess)">
            <summary>
            Opens a file that exists within the current directory
            </summary>
            <param name="fileName">Name with extension of the file</param>
            <param name="mode">File mode</param>
            <param name="access">File access</param>
            <returns>The open <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"/> from the current directory</returns>
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.OpenFile(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens a file that exists within the current directory
            </summary>
            <param name="fileName">Name with extension of the file</param>
            <param name="mode">File mode</param>
            <param name="access">File access</param>
            <param name="share">The file shareing mode</param>
            <returns>The open <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"/> from the current directory</returns>
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.FileExists(System.String)">
            <summary>
            Determiens if the specified file path refers to an existing file within the directory
            </summary>
            <param name="fileName">The name of the file to search for</param>
            <returns>True if the file exists within the current directory</returns>
            <exception cref="T:System.ArgumentNullException"></exception> 
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.IO.IsolatedStorage.IsolatedStorageException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception> 
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.Remove">
            <summary>
            Removes the directory and its contents from the store
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.IsolatedStorageDirectory.Parent">
            <summary>
            The parent <see cref="T:VNLib.Utils.IO.IsolatedStorageDirectory"/> this directory is a child within. null if there are no parent directories 
            above this dir
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.IsolatedStorageDirectory.CreateChildDirectory(System.String)">
            <summary>
            Creates a child directory within the current directory
            </summary>
            <param name="directoryName">The name of the child directory</param>
            <returns>A new <see cref="T:VNLib.Utils.IO.IsolatedStorageDirectory"/> for which <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFileStream"/>s can be opened/created</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:VNLib.Utils.IO.IVnTextReader">
            <summary>
            Represents a streaming text reader with internal buffers
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.IVnTextReader.BaseStream">
            <summary>
            The base stream to read data from
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.IVnTextReader.Encoding">
            <summary>
            The character encoding used by the TextReader
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.IVnTextReader.Available">
            <summary>
            Number of available bytes of buffered data within the current buffer window
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.IVnTextReader.LineTermination">
            <summary>
            Gets or sets the line termination used to deliminate a line of data
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.IVnTextReader.BufferedDataWindow">
            <summary>
            The unread/available data within the internal buffer
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.IVnTextReader.Advance(System.Int32)">
            <summary>
            Shifts the sliding buffer window by the specified number of bytes.
            </summary>
            <param name="count">The number of bytes read from the buffer</param>
        </member>
        <member name="M:VNLib.Utils.IO.IVnTextReader.FillBuffer">
            <summary>
            Reads data from the stream into the remaining buffer space for processing
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.IVnTextReader.CompactBufferWindow">
            <summary>
            Compacts the available buffer space back to the begining of the buffer region
            and determines if there is room for more data to be buffered
            </summary>
            <returns>The remaining buffer space if any</returns>
        </member>
        <member name="T:VNLib.Utils.IO.SlidingWindowBufferExtensions">
            <summary>
            Extention methods for <see cref="T:VNLib.Utils.IO.ISlindingWindowBuffer`1"/>
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.SlidingWindowBufferExtensions.CompactBufferWindow``1(VNLib.Utils.IO.ISlindingWindowBuffer{``0})">
            <summary>
            Shifts/resets the current buffered data window down to the 
            begining of the buffer if the buffer window is shifted away 
            from the begining.
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.SlidingWindowBufferExtensions.Reset``1(VNLib.Utils.IO.ISlindingWindowBuffer{``0})">
            <summary>
            Resets the buffer window back to the begining of the buffer
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sBuf"></param>
        </member>
        <member name="M:VNLib.Utils.IO.SlidingWindowBufferExtensions.Append``1(VNLib.Utils.IO.ISlindingWindowBuffer{``0},``0)">
            <summary>
            Appents the specified data to the end of the buffer 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sBuf"></param>
            <param name="val">The value to append to the end of the buffer</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.SlidingWindowBufferExtensions.Append``1(VNLib.Utils.IO.ISlindingWindowBuffer{``0},System.ReadOnlyMemory{``0})">
            <summary>
            Appents the specified data to the end of the buffer 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sBuf"></param>
            <param name="val">The value to append to the end of the buffer</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.SlidingWindowBufferExtensions.Append``1(VNLib.Utils.IO.ISlindingWindowBuffer{``0},System.ReadOnlySpan{``0})">
            <summary>
            Appents the specified data to the end of the buffer 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sBuf"></param>
            <param name="val">The value to append to the end of the buffer</param>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.SlidingWindowBufferExtensions.Advance``1(VNLib.Utils.IO.ISlindingWindowBuffer{``0},System.Int32)">
            <summary>
            Advances the end of the buffer window by the specified amount
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="sBuf"></param>
            <param name="count">The number of elements added to the end of the buffer</param>
        </member>
        <member name="M:VNLib.Utils.IO.SlidingWindowBufferExtensions.Read``1(VNLib.Utils.IO.ISlindingWindowBuffer{``0},System.Span{``0}@)">
            <summary>
            Reads available data from the current window and writes it to the supplied buffer
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="sBuf"></param>
            <param name="buffer">The output buffer to write data to</param>
            <returns>The number of elements written to the buffer</returns>
        </member>
        <member name="T:VNLib.Utils.IO.TemporayIsolatedFile">
            <summary>
            Allows for temporary files to be generated, used, then removed from an <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"/>
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.TemporayIsolatedFile.#ctor(VNLib.Utils.IO.IsolatedStorageDirectory)">
            <summary>
            Creates a new temporary filestream within the specified <see cref="T:System.IO.IsolatedStorage.IsolatedStorageFile"/>
            </summary>
            <param name="storage">The file store to genreate temporary files within</param>
        </member>
        <member name="P:VNLib.Utils.IO.VnBufferedStream.BaseStream">
            <summary>
            Gets the underlying stream that interfaces with the backing store
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.InitializeBuffer(System.Int32)">
            <summary>
            Invoked by the constuctor method to allocte the internal buffer with the specified buffer size.
            </summary>
            <param name="bufferSize">The requested size of the buffer to alloc</param>
            <remarks>By default requests the buffer from the <see cref="P:System.Buffers.ArrayPool`1.Shared"/> instance</remarks>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.Close">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.VnBufferedStream.CanRead">
            <summary>
            Always false
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnBufferedStream.CanSeek">
            <summary>
            Always returns false
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnBufferedStream.CanWrite">
            <summary>
            Always true
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnBufferedStream.Length">
            <summary>
            Returns the size of the underlying buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnBufferedStream.Position">
            <summary>
            Always throws <see cref="T:System.NotSupportedException"/>
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Always throws <see cref="T:System.NotSupportedException"/>
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Always throws <see cref="T:System.NotSupportedException"/>
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.SetLength(System.Int64)">
            <summary>
            Always throws <see cref="T:System.NotSupportedException"/>
            </summary>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnBufferedStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.IO.VnMemoryStream">
            <summary>
            Provides an unmanaged memory stream. Desigend to help reduce garbage collector load for 
            high frequency memory operations. 
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.ConsumeHandle(VNLib.Utils.Memory.MemoryHandle{System.Byte},System.Int64,System.Boolean)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.IO.VnMemoryStream"/> pointing to the begining of memory, and consumes the handle.
            </summary>
            <param name="handle"><see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/> to consume</param>
            <param name="length">Length of the stream</param>
            <param name="readOnly">Should the stream be readonly?</param>
            <exception cref="T:System.ArgumentException"></exception>
            <returns>A <see cref="T:VNLib.Utils.IO.VnMemoryStream"/> wrapper to access the handle data</returns>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.CreateReadonly(VNLib.Utils.IO.VnMemoryStream)">
            <summary>
            Converts a writable <see cref="T:VNLib.Utils.IO.VnMemoryStream"/> to readonly to allow shallow copies
            </summary>
            <param name="stream">The stream to make readonly</param>
            <returns>The readonly stream</returns>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.#ctor">
            <summary>
            Creates a new memory stream
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.#ctor(VNLib.Utils.Memory.IUnmangedHeap)">
            <summary>
            Create a new memory stream where buffers will be allocated from the specified heap
            </summary>
            <param name="heap"><see cref="T:VNLib.Utils.Memory.PrivateHeap"/> to allocate memory from</param>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.#ctor(VNLib.Utils.Memory.IUnmangedHeap,System.Int64,System.Boolean)">
            <summary>
            Creates a new memory stream and pre-allocates the internal
            buffer of the specified size on the specified heap to avoid resizing.
            </summary>
            <param name="heap"><see cref="T:VNLib.Utils.Memory.PrivateHeap"/> to allocate memory from</param>
            <param name="bufferSize">Number of bytes (length) of the stream if known</param>
            <param name="zero">Zero memory allocations during buffer expansions</param>
            <exception cref="T:System.InsufficientMemoryException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.#ctor(VNLib.Utils.Memory.IUnmangedHeap,System.ReadOnlySpan{System.Byte})">
            <summary>
            Creates a new memory stream from the data provided
            </summary>
            <param name="heap"><see cref="T:VNLib.Utils.Memory.PrivateHeap"/> to allocate memory from</param>
            <param name="data">Initial data</param>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.#ctor(VNLib.Utils.Memory.MemoryHandle{System.Byte},System.Int64,System.Boolean,System.Boolean)">
            <summary>
            WARNING: Dangerous constructor, make sure read-only and owns hanlde are set accordingly
            </summary>
            <param name="buffer">The buffer to referrence directly</param>
            <param name="length">The length property of the stream</param>
            <param name="readOnly">Is the stream readonly (should mostly be true!)</param>
            <param name="ownsHandle">Does the new stream own the memory -> <paramref name="buffer"/></param>
        </member>
        <member name="P:VNLib.Utils.IO.VnMemoryStream.LenToPosDiff">
            <summary>
            UNSAFE Number of bytes between position and length. Never negative
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.GetReadonlyShallowCopy">
            <summary>
            If the current stream is a readonly stream, creates an unsafe shallow copy for reading only.
            </summary>
            <returns>New stream shallow copy of the internal stream</returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.CopyTo(System.IO.Stream,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.VnMemoryStream.CanRead">
            <summary>
            <inheritdoc/>
            <para>
            This propery is always true
            </para>
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnMemoryStream.CanSeek">
            <summary>
            <inheritdoc/>
            <para>
            This propery is always true
            </para>
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnMemoryStream.CanWrite">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.VnMemoryStream.Length">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.VnMemoryStream.Position">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Close">
            <summary>
            Closes the stream and frees the internal allocated memory blocks
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Flush">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.FlushAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Read(System.Span{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.ReadAsync(System.Memory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.SetLength(System.Int64)">
            <summary>
            Resizes the internal buffer to the exact size (in bytes) of the 
            value argument. A value of 0 will free the entire buffer. A value 
            greater than zero will resize the buffer (and/or alloc)
            </summary>
            <param name="value">The size of the stream (and internal buffer)</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Write(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.WriteAsync(System.ReadOnlyMemory{System.Byte},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.WriteByte(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.ToArray">
            <summary>
            Allocates and copies internal buffer to new managed byte[]
            </summary>
            <returns>Copy of internal buffer</returns>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.AsSpan">
            <summary>
            Returns a <see cref="T:System.ReadOnlySpan`1"/> window over the data within the entire stream
            </summary>
            <returns>A <see cref="T:System.ReadOnlySpan`1"/> of the data within the entire stream</returns>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.Clone">
            <summary>
            If the current stream is a readonly stream, creates a shallow copy for reading only.
            </summary>
            <returns>New stream shallow copy of the internal stream</returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnMemoryStream.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.IO.VnStreamReader">
            <summary>
            Binary based buffered text reader, optimized for reading network streams
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamReader.BaseStream">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamReader.Encoding">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamReader.Available">
            <summary>
            Number of available bytes of buffered data within the current buffer window
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamReader.LineTermination">
            <summary>
            Gets or sets the line termination used to deliminate a line of data
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32)">
            <summary>
            Creates a new <see cref="T:System.IO.TextReader"/> that reads encoded data from the base.
            Internal buffers will be alloced from <see cref="P:System.Buffers.ArrayPool`1.Shared"/>
            </summary>
            <param name="baseStream">The underlying stream to read data from</param>
            <param name="enc">The <see cref="P:VNLib.Utils.IO.VnStreamReader.Encoding"/> to use when reading from the stream</param>
            <param name="bufferSize">The size of the internal binary buffer</param>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.InitializeBuffer(System.Int32)">
            <summary>
            Invoked by the constuctor method to allocte the internal buffer with the specified buffer size.
            </summary>
            <param name="bufferSize">The requested size of the buffer to alloc</param>
            <remarks>By default requests the buffer from the <see cref="P:System.Buffers.ArrayPool`1.Shared"/> instance</remarks>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.ReadLineAsync">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.FillBufferAsync(System.Threading.CancellationToken)">
            <summary>
            Fill the end of the current buffer with data from the stream and update the positions
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.Read(System.Char[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.Read(System.Span{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.Close">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamReader.ClearBuffer">
            <summary>
            Resets the internal buffer window
            </summary>
        </member>
        <member name="T:VNLib.Utils.IO.VnStreamWriter">
            <summary>
            Provides a memory optimized <see cref="T:System.IO.TextWriter"/> implementation. Optimized for writing
            to network streams
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamWriter.BaseStream">
            <summary>
            Gets the underlying stream that interfaces with the backing store
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamWriter.Encoding">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamWriter.LineTermination">
            <summary>
            Line termination to use when writing lines to the output
            </summary>
        </member>
        <member name="P:VNLib.Utils.IO.VnStreamWriter.NewLine">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.#ctor(System.IO.Stream,System.Text.Encoding,System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.IO.VnStreamWriter"/> that writes formatted data
            to the specified base stream
            </summary>
            <param name="baseStream">The stream to write data to</param>
            <param name="encoding">The <see cref="P:VNLib.Utils.IO.VnStreamWriter.Encoding"/> to use when writing data</param>
            <param name="bufferSize">The size of the internal buffer used to buffer binary data before writing to the base stream</param>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.InitializeBuffer(System.Int32)">
            <summary>
            Invoked by the constuctor method to allocte the internal buffer with the specified buffer size.
            </summary>
            <param name="bufferSize">The requested size of the buffer to alloc</param>
            <remarks>By default requests the buffer from the <see cref="P:System.Buffers.MemoryPool`1.Shared"/> instance</remarks>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Write(System.Byte)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Write(System.Char)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Write(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Write(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Write(System.ReadOnlySpan{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.WriteAsync(System.ReadOnlyMemory{System.Char},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.WriteAsyncSync(System.ReadOnlyMemory{System.Char},System.Threading.CancellationToken)">
            <summary>
            Asynchronously writes a character memory region to the text stream
            </summary>
            <param name="value">The character buffer to write to encode and write to the stream</param>
            <param name="cancellationToken">A token to cancel the async operation</param>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that represents the asynchronous write operation</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.WriteLine">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.WriteLine(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.WriteLine(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.WriteLine(System.ReadOnlySpan{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Flush">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.FlushWriterAsync(System.Threading.CancellationToken)">
            <summary>
            Asynchronously flushes the internal buffers to the <see cref="P:VNLib.Utils.IO.VnStreamWriter.BaseStream"/>, and resets the internal buffer state
            </summary>
            <returns>A <see cref="T:System.Threading.Tasks.ValueTask"/> that represents the asynchronous flush operation</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.FlushAsync">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Reset">
            <summary>
            Resets internal properies for resuse
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Close">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.IO.VnStreamWriter.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.IO.VnTextReaderExtensions">
            <summary>
            Extension methods to help reuse code for used TextReader implementations
            </summary>
        </member>
        <member name="M:VNLib.Utils.IO.VnTextReaderExtensions.ReadLine``1(``0@,System.Span{System.Char})">
            <summary>
            Attempts to read a line from the stream and store it in the specified buffer
            </summary>
            <param name="reader"></param>
            <param name="charBuffer">The character buffer to write data to</param>
            <returns>Returns the number of bytes read, <see cref="F:VNLib.Utils.IO.VnTextReaderExtensions.E_BUFFER_TOO_SMALL"/> 
            if the buffer was not large enough, 0 if no data was available</returns>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <remarks>Allows reading lines of data from the stream without allocations</remarks>
        </member>
        <member name="M:VNLib.Utils.IO.VnTextReaderExtensions.ReadLine``1(``0,System.Span{System.Char})">
            <summary>
            Attempts to read a line from the stream and store it in the specified buffer
            </summary>
            <param name="reader"></param>
            <param name="charBuffer">The character buffer to write data to</param>
            <returns>Returns the number of bytes read, <see cref="F:VNLib.Utils.IO.VnTextReaderExtensions.E_BUFFER_TOO_SMALL"/> 
            if the buffer was not large enough, 0 if no data was available</returns>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <remarks>Allows reading lines of data from the stream without allocations</remarks>
        </member>
        <member name="M:VNLib.Utils.IO.VnTextReaderExtensions.ReadRemaining``1(``0@,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Fill a buffer with reamining buffered data 
            </summary>
            <param name="reader"></param>
            <param name="buffer">Buffer to copy data to</param>
            <param name="offset">Offset in buffer to begin writing</param>
            <param name="count">Number of bytes to read</param>
            <returns>The number of bytes copied to the input buffer</returns>
        </member>
        <member name="M:VNLib.Utils.IO.VnTextReaderExtensions.ReadRemaining``1(``0,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Fill a buffer with reamining buffered data 
            </summary>
            <param name="reader"></param>
            <param name="buffer">Buffer to copy data to</param>
            <param name="offset">Offset in buffer to begin writing</param>
            <param name="count">Number of bytes to read</param>
            <returns>The number of bytes copied to the input buffer</returns>
        </member>
        <member name="M:VNLib.Utils.IO.VnTextReaderExtensions.ReadRemaining``1(``0@,System.Span{System.Byte})">
            <summary>
            Fill a buffer with reamining buffered data, up to 
            the size of the supplied buffer
            </summary>
            <param name="reader"></param>
            <param name="buffer">Buffer to copy data to</param>
            <returns>The number of bytes copied to the input buffer</returns>
            <remarks>You should use the <see cref="P:VNLib.Utils.IO.IVnTextReader.Available"/> property to know how much remaining data is buffered</remarks>
        </member>
        <member name="M:VNLib.Utils.IO.VnTextReaderExtensions.ReadRemaining``1(``0,System.Span{System.Byte})">
            <summary>
            Fill a buffer with reamining buffered data, up to 
            the size of the supplied buffer
            </summary>
            <param name="reader"></param>
            <param name="buffer">Buffer to copy data to</param>
            <returns>The number of bytes copied to the input buffer</returns>
            <remarks>You should use the <see cref="P:VNLib.Utils.IO.IVnTextReader.Available"/> property to know how much remaining data is buffered</remarks>
        </member>
        <member name="T:VNLib.Utils.Logging.ILogProvider">
            <summary>
            Self-contained logging interface that allows for applications events to be written to an
            output source
            </summary>
        </member>
        <member name="M:VNLib.Utils.Logging.ILogProvider.Flush">
            <summary>
            Flushes any buffers to the output source
            </summary>
        </member>
        <member name="M:VNLib.Utils.Logging.ILogProvider.Write(VNLib.Utils.Logging.LogLevel,System.String)">
            <summary>
            Writes the string to the log with the specified priority log level
            </summary>
            <param name="level">The log priority level</param>
            <param name="value">The message to print</param>
        </member>
        <member name="M:VNLib.Utils.Logging.ILogProvider.Write(VNLib.Utils.Logging.LogLevel,System.Exception,System.String)">
            <summary>
            Writes the exception and optional string to the log with the specified priority log level
            </summary>
            <param name="level">The log priority level</param>
            <param name="exception">An exception object to write</param>
            <param name="value">The message to print</param>
        </member>
        <member name="M:VNLib.Utils.Logging.ILogProvider.Write(VNLib.Utils.Logging.LogLevel,System.String,System.Object[])">
            <summary>
            Writes the template string and params arguments to the log with the specified priority log level
            </summary>
             <param name="level">The log priority level</param>
            <param name="value">The log template string</param>
            <param name="args">Variable length array of objects to log with the specified templatre</param>
        </member>
        <member name="M:VNLib.Utils.Logging.ILogProvider.Write(VNLib.Utils.Logging.LogLevel,System.String,System.ValueType[])">
            <summary>
            Writes the template string and params arguments to the log with the specified priority log level
            </summary>
             <param name="level">The log priority level</param>
            <param name="value">The log template string</param>
            <param name="args">Variable length array of objects to log with the specified templatre</param>
        </member>
        <member name="M:VNLib.Utils.Logging.ILogProvider.GetLogProvider">
            <summary>
            Gets the underlying log source
            </summary>
            <returns>The underlying log source</returns>
        </member>
        <member name="M:VNLib.Utils.Logging.ILogProvider.GetLogProvider``1">
            <summary>
            Gets the underlying log source
            </summary>
            <returns>The underlying log source</returns>
        </member>
        <member name="T:VNLib.Utils.Logging.LoggerExtensions">
            <summary>
            Extension helper methods for writing logs to a <see cref="T:VNLib.Utils.Logging.ILogProvider"/>
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.CacheTimerTimeout">
            <summary>
            The default time period for the timer's initial timeout state.This is used for catching fault conditions
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.Prepare">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.Release">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.WaitOne(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.WaitOneAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.CacheTimerElapsed">
            <summary>
            Invoked when the timer has elapsed 
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.ResumeTimer(System.TimeSpan)">
            <summary>
            Resumes a previously stopped timer to the specified timeout period
            </summary>
            <param name="timeout">The amount of time the timer should wait before invoking the <see cref="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.CacheTimerElapsed"/> method</param>
            <returns>The result of the timer reset</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.CacheableAsyncExclusive`1.DisposeAsync">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.ICacheable">
            <summary>
            Represents a cacheable entity with an expiration
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.ICacheable.Expires">
            <summary>
            A <see cref="T:System.DateTime"/> value that the entry is no longer valid
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ICacheable.Evicted">
            <summary>
            Invoked when a collection occurs
            </summary>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.ICacheHolder">
            <summary>
            Exposes basic control of classes that manage private caches
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ICacheHolder.CacheClear">
            <summary>
            Clears all held caches without causing application stopping effects. 
            </summary>
            <remarks>This is a safe "light" cache clear</remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ICacheHolder.CacheHardClear">
            <summary>
            Performs all necessary actions to clear all held caches immediatly.
            </summary>
            <remarks>A "hard" cache clear/reset regardless of cost</remarks>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.IReusable">
            <summary>
            Allows for use within a <see cref="T:VNLib.Utils.Memory.Caching.ReusableStore`1"/>, this object is intended to be reused heavily
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.IReusable.Prepare">
            <summary>
            The instance should prepare itself for use (or re-use)
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.IReusable.Release">
            <summary>
            The intance is being returned and should determine if it's state is reusabled
            </summary>
            <returns>true if the instance can/should be reused, false if it should not be reused</returns>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.LRUCache`2">
            <summary>
            A base class for a Least Recently Used cache 
            </summary>
            <typeparam name="TKey">The key for O(1) lookups</typeparam>
            <typeparam name="TValue">The value to store within cache</typeparam>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.#ctor(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.LRUCache`2.MaxCapacity">
            <summary>
            The maximum number of items to store in LRU cache
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds a new record to the LRU cache 
            </summary>
            <param name="item">A <see cref="T:System.Collections.Generic.KeyValuePair`2"/> to add to the cache store</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.TryGetValue(`0,`1@)">
            <summary>
            Attempts to get a value by the given key. 
            </summary>
            <param name="key">The key identifying the value to store</param>
            <param name="value">The value to store</param>
            <returns>A value indicating if the value was found in the store</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.Evicted(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Invoked when a record is evicted from the cache
            </summary>
            <param name="evicted">The record that is being evicted</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUCache`2.CacheMiss(`0,`1@)">
            <summary>
            Invoked when an entry was requested and was not found in cache.
            </summary>
            <param name="key">The key identifying the record to lookup</param>
            <param name="value">The found value matching the key</param>
            <returns>A value indicating if the record was found</returns>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.LRUDataStore`2">
            <summary>
            A Least Recently Used store base class for E2E O(1) operations
            </summary>
            <typeparam name="TKey">A key used for O(1) lookups</typeparam>
            <typeparam name="TValue">A value to store</typeparam>
        </member>
        <member name="F:VNLib.Utils.Memory.Caching.LRUDataStore`2.LookupTable">
            <summary>
            A lookup table that provides O(1) access times for key-value lookups
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.Caching.LRUDataStore`2.List">
            <summary>
            A linked list that tracks the least recently used item. 
            New items (or recently access items) are moved to the end of the list.
            The head contains the least recently used item
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.#ctor">
            <summary>
            Initializes an empty <see cref="T:VNLib.Utils.Memory.Caching.LRUDataStore`2"/>
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.#ctor(System.Int32)">
            <summary>
            Initializes an empty <see cref="T:VNLib.Utils.Memory.Caching.LRUDataStore`2"/> and sets
            the lookup table's inital capacity
            </summary>
            <param name="initialCapacity">LookupTable initial capacity</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes an empty <see cref="T:VNLib.Utils.Memory.Caching.LRUDataStore`2"/> and uses the 
            specified keycomparison 
            </summary>
            <param name="keyComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> used by the Lookuptable to compare keys</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes an empty <see cref="T:VNLib.Utils.Memory.Caching.LRUDataStore`2"/> and uses the 
            specified keycomparison, and sets the lookup table's initial capacity
            </summary>
            <param name="initialCapacity">LookupTable initial capacity</param>
            <param name="keyComparer">A <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> used by the Lookuptable to compare keys</param>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.LRUDataStore`2.Item(`0)">
            <summary>
            Gets or sets a value within the LRU cache.
            </summary>
            <param name="key">The key identifying the value</param>
            <returns>The value stored at the given key</returns>
            <remarks>Items are promoted in the store when accessed</remarks>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.LRUDataStore`2.Keys">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.LRUDataStore`2.Values">
            <inheritdoc/>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.LRUDataStore`2.Count">
            <summary>
            Gets the number of items within the LRU store
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.Caching.LRUDataStore`2.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.Add(`0,`1)">
            <summary>
            Adds the specified record to the store and places it at the end of the LRU queue
            </summary>
            <param name="key">The key identifying the record</param>
            <param name="value">The value to store at the key</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.ContainsKey(`0)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Adds the specified record to the store and places it at the end of the LRU queue
            </summary>
            <param name="item">The item to add</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.Clear">
            <summary>
            Removes all elements from the LRU store
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines if the <see cref="T:System.Collections.Generic.KeyValuePair`2"/> exists in the store
            </summary>
            <param name="item">The record to search for</param>
            <returns>True if the key was found in the store and the value equals the stored value, false otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.LRUDataStore`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get a value from the store with its key. Found items are promoted
            </summary>
            <param name="key">The key identifying the value</param>
            <param name="value">The found value</param>
            <returns>A value indicating if the element was found in the store</returns>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.ObjectRental`1">
            <summary>
            Provides concurrent storage for reusable objects to be rented and returned. This class
            and its members is thread-safe
            </summary>
            <typeparam name="T">The data type to reuse</typeparam>
        </member>
        <member name="F:VNLib.Utils.Memory.Caching.ObjectRental`1.INITIAL_STRUCTURE_SIZE">
            <summary>
            The initial data-structure capacity if quota is not defined
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.Caching.ObjectRental`1.IsDisposableType">
            <summary>
            Is the object type in the current store implement the Idisposable interface?
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.Caching.ObjectRental`1.QuotaLimit">
            <summary>
            The maximum number of objects that will be cached.
            Once this threshold has been reached, objects are 
            no longer stored
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental`1.#ctor(System.Func{`0},System.Action{`0},System.Action{`0},System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ObjectRental`1"/> store with the rent/return callback methods
            </summary>
            <param name="constructor"></param>
            <param name="rentCb">The pre-retnal preperation action</param>
            <param name="returnCb">The pre-return cleanup action</param>
            <param name="quota"></param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental`1.Rent">
            <summary>
            Gets an object from the store, or creates a new one if none are available
            </summary>
            <returns>An instance of <typeparamref name="T"/> from the store if available or a new instance if none were available</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental`1.Lease">
            <summary>
            Leases an object from the store that will be returned to the store when disposed
            </summary>
            <returns>A new <see cref="T:VNLib.Utils.OpenResourceHandle`1"/> for the leased object</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental`1.Return(`0)">
            <summary>
            Returns a rented object back to the rental store for reuse
            </summary>
            <param name="item">The previously rented item</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental`1.CacheClear">
            <remarks>
            NOTE: If <typeparamref name="T"/> implements <see cref="T:System.IDisposable"/>
            interface, this method does nothing
            </remarks>
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental`1.CacheHardClear">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental`1.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.ObjectRental">
            <summary>
            Provides concurrent storage for reusable objects to be rented and returned. This class
            and its members is thread-safe
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.Create``1(System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ObjectRental`1"/> store
            </summary>
            <param name="quota">The maximum number of elements that will be cached</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.Create``1(System.Action{``0},System.Action{``0},System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ObjectRental`1"/> store with generic rental and return callback handlers
            </summary>
            <param name="rentCb">Function responsible for preparing an instance to be rented</param>
            <param name="returnCb">Function responsible for cleaning up an instance before reuse</param>
            <param name="quota">The maximum number of elements that will be cached</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.Create``1(System.Func{``0},System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ObjectRental`1"/> store with a generic constructor function
            </summary>
            <param name="constructor">The function invoked to create a new instance when required</param>
            <param name="quota">The maximum number of elements that will be cached</param>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.Create``1(System.Func{``0},System.Action{``0},System.Action{``0},System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ObjectRental`1"/> store with generic rental and return callback handlers
            </summary>
            <param name="constructor">The function invoked to create a new instance when required</param>
            <param name="rentCb">Function responsible for preparing an instance to be rented</param>
            <param name="returnCb">Function responsible for cleaning up an instance before reuse</param>
            <param name="quota">The maximum number of elements that will be cached</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateThreadLocal``1(System.Func{``0},System.Action{``0},System.Action{``0})">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1"/> store with generic rental and return callback handlers
            </summary>
            <typeparam name="TNew"></typeparam>
            <param name="constructor">The function invoked to create a new instance when required</param>
            <param name="rentCb">Function responsible for preparing an instance to be rented</param>
            <param name="returnCb">Function responsible for cleaning up an instance before reuse</param>
            <returns>The initialized store</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateThreadLocal``1(System.Action{``0},System.Action{``0})">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1"/> store with generic rental and return callback handlers
            </summary>
            <param name="rentCb">Function responsible for preparing an instance to be rented</param>
            <param name="returnCb">Function responsible for cleaning up an instance before reuse</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateThreadLocal``1">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1"/> store
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateThreadLocal``1(System.Func{``0})">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1"/> store with a generic constructor function
            </summary>
            <param name="constructor">The function invoked to create a new instance when required</param>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateReusable``1(System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ReusableStore`1"/> instance with a parameterless constructor
            </summary>
            <typeparam name="T">The <see cref="T:VNLib.Utils.Memory.Caching.IReusable"/> type</typeparam>
            <param name="quota">The maximum number of elements that will be cached</param>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateReusable``1(System.Func{``0},System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ReusableStore`1"/> instance with the specified constructor
            </summary>
            <typeparam name="T">The <see cref="T:VNLib.Utils.Memory.Caching.IReusable"/> type</typeparam>
            <param name="constructor">The constructor function invoked to create new instances of the <see cref="T:VNLib.Utils.Memory.Caching.IReusable"/> type</param>
            <param name="quota">The maximum number of elements that will be cached</param>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateThreadLocalReusable``1">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalReusableStore`1"/> instance with a parameterless constructor
            </summary>
            <typeparam name="T">The <see cref="T:VNLib.Utils.Memory.Caching.IReusable"/> type</typeparam>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ObjectRental.CreateThreadLocalReusable``1(System.Func{``0})">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalReusableStore`1"/> instance with the specified constructor
            </summary>
            <typeparam name="T">The <see cref="T:VNLib.Utils.Memory.Caching.IReusable"/> type</typeparam>
            <param name="constructor">The constructor function invoked to create new instances of the <see cref="T:VNLib.Utils.Memory.Caching.IReusable"/> type</param>
            <returns></returns>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.ReusableStore`1">
            <summary>
            A reusable object store that extends <see cref="T:VNLib.Utils.Memory.Caching.ObjectRental`1"/>, that allows for objects to be reused heavily
            </summary>
            <typeparam name="T">A reusable object</typeparam>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ReusableStore`1.Rent">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ReusableStore`1.Return(`0)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1">
            <summary>
            Derrives from <see cref="T:VNLib.Utils.Memory.Caching.ObjectRental`1"/> to provide object rental syntax for <see cref="T:System.Threading.ThreadLocal`1"/> 
            storage
            </summary>
            <typeparam name="T">The data type to store</typeparam>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1.Rent">
            <summary>
            "Rents" or creates an object for the current thread
            </summary>
            <returns>The new or stored instanced</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1.Return(`0)">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.Caching.ThreadLocalReusableStore`1">
            <summary>
            A reusable object store that extends <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalObjectStorage`1"/>, that allows for objects to be reused heavily
            in a thread-local cache
            </summary>
            <typeparam name="T">A reusable object</typeparam>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ThreadLocalReusableStore`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.Caching.ThreadLocalReusableStore`1"/> instance
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ThreadLocalReusableStore`1.Rent">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.Caching.ThreadLocalReusableStore`1.Return(`0)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.IMemoryHandle`1">
            <summary>
            Represents a handle for safe access to memory managed/unamanged memory
            </summary>
            <typeparam name="T">The type this handle represents</typeparam>
        </member>
        <member name="P:VNLib.Utils.Memory.IMemoryHandle`1.IntLength">
            <summary>
            The size of the block as an integer
            </summary>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.IMemoryHandle`1.Length">
            <summary>
            The number of elements in the block
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.IMemoryHandle`1.Span">
            <summary>
            Gets the internal block as a span
            </summary>
        </member>
        <member name="T:VNLib.Utils.Memory.IStringSerializeable">
            <summary>
            A interface that provides indempodent abstractions for compiling an instance
            to its representitive string.
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.IStringSerializeable.Compile">
            <summary>
            Compiles the current instance into its safe string representation
            </summary>
            <returns>A string of the desired representation of the current instance</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.IStringSerializeable.Compile(VNLib.Utils.Memory.VnBufferWriter{System.Char}@)">
            <summary>
            Compiles the current instance into its safe string representation, and writes its 
            contents to the specified buffer writer
            </summary>
            <param name="writer">The ouput writer to write the serialized representation to</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.IStringSerializeable.Compile(System.Span{System.Char}@)">
            <summary>
            Compiles the current instance into its safe string representation, and writes its 
            contents to the specified buffer writer
            </summary>
            <param name="buffer">The buffer to write the serialized representation to</param>
            <returns>The number of characters written to the buffer</returns>
        </member>
        <member name="T:VNLib.Utils.Memory.IUnmangedHeap">
            <summary>
            Abstraction for handling (allocating, resizing, and freeing) blocks of unmanaged memory from an unmanged heap
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.IUnmangedHeap.Alloc(System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Allocates a block of memory from the heap and returns a pointer to the new memory block
            </summary>
            <param name="size">The size (in bytes) of the element</param>
            <param name="elements">The number of elements to allocate</param>
            <param name="zero">An optional parameter to zero the block of memory</param>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.Memory.IUnmangedHeap.Resize(System.IntPtr@,System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Resizes the allocated block of memory to the new size
            </summary>
            <param name="block">The block to resize</param>
            <param name="elements">The new number of elements</param>
            <param name="size">The size (in bytes) of the type</param>
            <param name="zero">An optional parameter to zero the block of memory</param>
        </member>
        <member name="M:VNLib.Utils.Memory.IUnmangedHeap.Free(System.IntPtr@)">
            <summary>
            Free's a previously allocated block of memory
            </summary>
            <param name="block">The memory to be freed</param>
            <returns>A value indicating if the free operation succeeded</returns>
        </member>
        <member name="T:VNLib.Utils.Memory.Memory">
            <summary>
            Provides optimized cross-platform maanged/umanaged safe/unsafe memory operations
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.Memory.SHARED_HEAP_INIT_SIZE">
            <summary>
            Initial shared heap size (bytes)
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.Memory.MAX_UNSAFE_POOL_SIZE">
            <summary>
            The maximum buffer size requested by <see cref="M:VNLib.Utils.Memory.Memory.UnsafeAlloc``1(System.Int32,System.Boolean)"/>
            that will use the array pool before falling back to the <see cref="P:VNLib.Utils.Memory.Memory.Shared"/>.
            heap.
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.Memory.Shared">
            <summary>
            Provides a shared heap instance for the process to allocate memory from.
            </summary>
            <remarks>
            The backing heap
            is determined by the OS type and process environment varibles.
            </remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.InitializeNewHeapForProcess">
            <summary>
            Initializes a new <see cref="T:VNLib.Utils.Memory.IUnmangedHeap"/> determined by compilation/runtime flags
            and operating system type for the current proccess.
            </summary>
            <returns>An <see cref="T:VNLib.Utils.Memory.IUnmangedHeap"/> for the current process</returns>
            <exception cref="T:System.SystemException"></exception>
            <exception cref="T:System.DllNotFoundException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.UnsafeZeroMemory``1(System.ReadOnlySpan{``0})">
            <summary>
            Zeros a block of memory of umanged type.  If Windows is detected at runtime, calls RtlSecureZeroMemory Win32 function
            </summary>
            <typeparam name="T">Unmanged datatype</typeparam>
            <param name="block">Block of memory to be cleared</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.UnsafeZeroMemory``1(System.ReadOnlyMemory{``0})">
            <summary>
            Zeros a block of memory of umanged type.  If Windows is detected at runtime, calls RtlSecureZeroMemory Win32 function
            </summary>
            <typeparam name="T">Unmanged datatype</typeparam>
            <param name="block">Block of memory to be cleared</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.InitializeBlock``1(System.Span{``0})">
            <summary>
            Initializes a block of memory with zeros 
            </summary>
            <typeparam name="T">The unmanaged</typeparam>
            <param name="block">The block of memory to initialize</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.InitializeBlock``1(System.Memory{``0})">
            <summary>
            Initializes a block of memory with zeros 
            </summary>
            <typeparam name="T">The unmanaged</typeparam>
            <param name="block">The block of memory to initialize</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.ZeroStruct``1(System.IntPtr)">
            <summary>
            Zeroes a block of memory pointing to the structure
            </summary>
            <typeparam name="T">The structure type</typeparam>
            <param name="block">The pointer to the allocated structure</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.ZeroStruct``1(System.Void*)">
            <summary>
            Zeroes a block of memory pointing to the structure
            </summary>
            <typeparam name="T">The structure type</typeparam>
            <param name="structPtr">The pointer to the allocated structure</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.ZeroStruct``1(``0*)">
            <summary>
            Zeroes a block of memory pointing to the structure
            </summary>
            <typeparam name="T">The structure type</typeparam>
            <param name="structPtr">The pointer to the allocated structure</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.Copy``1(System.ReadOnlySpan{``0},VNLib.Utils.Memory.MemoryHandle{``0},System.Int64)">
            <summary>
            Copies data from source memory to destination memory of an umanged data type
            </summary>
            <typeparam name="T">Unmanged type</typeparam>
            <param name="source">Source data <see cref="T:System.ReadOnlySpan`1"/></param>
            <param name="dest">Destination <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/></param>
            <param name="destOffset">Dest offset</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.Copy``1(System.ReadOnlyMemory{``0},VNLib.Utils.Memory.MemoryHandle{``0},System.Int64)">
            <summary>
            Copies data from source memory to destination memory of an umanged data type
            </summary>
            <typeparam name="T">Unmanged type</typeparam>
            <param name="source">Source data <see cref="T:System.ReadOnlyMemory`1"/></param>
            <param name="dest">Destination <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/></param>
            <param name="destOffset">Dest offset</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.Copy``1(VNLib.Utils.Memory.MemoryHandle{``0},System.Int64,System.Span{``0},System.Int32,System.Int32)">
            <summary>
            Copies data from source memory to destination memory of an umanged data type
            </summary>
            <typeparam name="T">Unmanged type</typeparam>
            <param name="source">Source data <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/></param>
            <param name="sourceOffset">Number of elements to offset source data</param>
            <param name="dest">Destination <see cref="T:System.Span`1"/></param>
            <param name="destOffset">Dest offset</param>
            <param name="count">Number of elements to copy</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.Copy``1(VNLib.Utils.Memory.MemoryHandle{``0},System.Int64,System.Memory{``0},System.Int32,System.Int32)">
            <summary>
            Copies data from source memory to destination memory of an umanged data type
            </summary>
            <typeparam name="T">Unmanged type</typeparam>
            <param name="source">Source data <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/></param>
            <param name="sourceOffset">Number of elements to offset source data</param>
            <param name="dest">Destination <see cref="T:System.Memory`1"/></param>
            <param name="destOffset">Dest offset</param>
            <param name="count">Number of elements to copy</param>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.Copy(System.IO.Stream,System.Int64,System.IO.Stream,System.Int64,System.Int64)">
            <summary>
            Copies data from one stream to another in specified blocks
            </summary>
            <param name="source">Source memory</param>
            <param name="srcOffset">Source offset</param>
            <param name="dest">Destination memory</param>
            <param name="destOffst">Destination offset</param>
            <param name="count">Number of elements to copy</param>
        </member>
        <member name="M:VNLib.Utils.Memory.Memory.UnsafeAlloc``1(System.Int32,System.Boolean)">
            <summary>
            Allocates a block of unmanaged, or pooled manaaged memory depending on
            compilation flags and runtime unamanged allocators.
            </summary>
            <typeparam name="T">The unamanged type to allocate</typeparam>
            <param name="elements">The number of elements of the type within the block</param>
            <param name="zero">Flag to zero elements during allocation before the method returns</param>
            <returns>A handle to the block of memory</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="T:VNLib.Utils.Memory.MemoryHandle`1">
            <summary>
            Provides a wrapper for using umanged memory handles from an assigned <see cref="T:VNLib.Utils.Memory.PrivateHeap"/> for <see cref="T:System.Runtime.InteropServices.UnmanagedType"/> types
            </summary>
            <remarks>
            Handles are configured to address blocks larger than 2GB,
            so some properties may raise exceptions if large blocks are used.
            </remarks>
        </member>
        <member name="P:VNLib.Utils.Memory.MemoryHandle`1.Base">
            <summary>
            New <typeparamref name="T"/>* pointing to the base of the allocated block
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.MemoryHandle`1.BasePtr">
            <summary>
            New <see cref="T:System.IntPtr"/> pointing to the base of the allocated block
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.MemoryHandle`1.Span">
            <summary>
            Gets a span over the entire allocated block
            </summary>
            <returns>A <see cref="T:System.Span`1"/> over the internal data</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.MemoryHandle`1.Length">
            <summary>
            Number of elements allocated to the current instance
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.MemoryHandle`1.IntLength">
            <summary>
            Number of elements in the memory block casted to an integer
            </summary>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.MemoryHandle`1.ByteLength">
            <summary>
            Number of bytes allocated to the current instance
            </summary>
            <exception cref="T:System.OverflowException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.#ctor(VNLib.Utils.Memory.IUnmangedHeap,System.IntPtr,System.UInt64,System.Boolean)">
            <summary>
            Creates a new memory handle, for which is holds ownership, and allocates the number of elements specified on the heap.
            </summary>
            <param name="heap">The heap to allocate/deallocate memory from</param>
            <param name="elements">Number of elements to allocate</param>
            <param name="zero">Zero all memory during allocations from heap</param>
            <param name="initial">The initial block of allocated memory to wrap</param>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.Resize(System.UInt64)">
            <summary>
            Resizes the current handle on the heap
            </summary>
            <param name="elements">Positive number of elemnts the current handle should referrence</param>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.GetOffset(System.UInt64)">
            <summary>
            Gets an offset pointer from the base postion to the number of bytes specified. Performs bounds checks
            </summary>
            <param name="elements">Number of elements of type to offset</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <returns><typeparamref name="T"/> pointer to the memory offset specified</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.ReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.Equals(VNLib.Utils.Memory.MemoryHandle{`0})">
            <summary>
            Determines if the memory blocks are equal by comparing their base addresses.
            </summary>
            <param name="other"><see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/> to compare</param>
            <returns>true if the block of memory is the same, false if the handle's size does not 
            match or the base addresses do not match even if they point to an overlapping address space</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.MemoryHandle`1.op_Implicit(VNLib.Utils.Memory.MemoryHandle{`0})~System.Span{`0}">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.PrivateBuffersMemoryPool`1">
            <summary>
            Provides a <see cref="T:System.Buffers.MemoryPool`1"/> wrapper for using unmanged <see cref="T:VNLib.Utils.Memory.PrivateHeap"/>s
            </summary>
            <typeparam name="T">Unamanged memory type to provide data memory instances from</typeparam>
        </member>
        <member name="P:VNLib.Utils.Memory.PrivateBuffersMemoryPool`1.MaxBufferSize">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateBuffersMemoryPool`1.Rent(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateBuffersMemoryPool`1.Rent``1(System.Int32)">
            <summary>
            Allocates a new <see cref="T:System.Buffers.MemoryManager`1"/> of a different data type from the pool
            </summary>
            <typeparam name="DifType">The unmanaged data type to allocate for</typeparam>
            <param name="minBufferSize">Minumum size of the buffer</param>
            <returns>The memory owner of a different data type</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateBuffersMemoryPool`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.PrivateHeap">
            <summary>
            <para>
             Provides a win32 private heap managed wrapper class
            </para>
            </summary>
            <remarks>
             <see cref="T:VNLib.Utils.Memory.PrivateHeap"/> implements <see cref="T:System.Runtime.InteropServices.SafeHandle"/> and tracks allocated blocks by its 
             referrence counter. Allocations increment the count, and free's decrement the count, so the heap may 
             be disposed safely
             </remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.Create(System.UInt64,System.UInt64,System.Int64)">
            <summary>
            Create a new <see cref="T:VNLib.Utils.Memory.PrivateHeap"/> with the specified sizes and flags
            </summary>
            <param name="initialSize">Intial size of the heap</param>
            <param name="maxHeapSize">Maximum size allowed for the heap (disabled = 0, default)</param>
            <param name="flags">Defalt heap flags to set globally for all blocks allocated by the heap (default = 0)</param>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.ConsumeExisting(System.IntPtr)">
            <summary>
            LIFETIME WARNING. Consumes a valid win32 handle and will manage it's lifetime once constructed.
            Locking and memory blocks will attempt to be allocated from this heap handle.
            </summary>
            <param name="win32HeapHandle">An open and valid handle to a win32 private heap</param>
            <returns>A wrapper around the specified heap</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.HeapSize(System.IntPtr@)">
            <summary>
            Retrieves the size of a memory block allocated from the current heap.
            </summary>
            <param name="block">The pointer to a block of memory to get the size of</param>
            <returns>The size of the block of memory, (SIZE_T)-1 if the operation fails</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.Validate(System.IntPtr@)">
            <summary>
            Validates the specified block of memory within the current heap instance. This function will block hte 
            </summary>
            <param name="block">Pointer to the block of memory to validate</param>
            <returns>True if the block is valid, false otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.Validate">
            <summary>
            Validates the current heap instance. The function scans all the memory blocks in the heap and verifies that the heap control structures maintained by 
            the heap manager are in a consistent state.
            </summary>
            <returns>If the specified heap or memory block is valid, the return value is nonzero.</returns>
            <remarks>This can be a consuming operation which will block all allocations</remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.ReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.AllocBlock(System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.FreeBlock(System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateHeap.ReAllocBlock(System.IntPtr,System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.PrivateString">
            <summary>
            Provides a wrapper class that will have unsafe access to the memory of 
            the specified <see cref="T:System.String"/> provided during object creation. 
            </summary>
            <remarks>The value of the memory the protected string points to is undefined when the instance is disposed</remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.#ctor(System.String@,System.Boolean)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.PrivateString"/> over the specified string and the memory it points to.
            </summary>
            <param name="data">The <see cref="T:System.String"/> instance pointing to the memory to protect</param>
            <param name="ownsReferrence">Does the current instance "own" the memory the data parameter points to</param>
            <remarks>You should no longer reference the input string directly</remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.Equals(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.Equals(VNLib.Utils.Memory.PrivateString)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.Equals(System.ReadOnlySpan{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.ToString">
            <summary>
            Creates a deep copy of the internal string and returns that copy
            </summary>
            <returns>A deep copy of the internal string</returns>
        </member>
        <member name="P:VNLib.Utils.Memory.PrivateString.Length">
            <summary>
            String length
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.IsNullOrEmpty(VNLib.Utils.Memory.PrivateString)">
            <summary>
            Indicates whether the underlying string is null or an empty string ("")
            </summary>
            <param name="ps"></param>
            <returns>True if the parameter is null, or an empty string (""). False otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.GetHashCode">
            <summary>
            The hashcode of the underlying string
            </summary>
            <returns></returns>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.Clone">
            <summary>
            Creates a new deep copy of the current instance that is an independent <see cref="T:VNLib.Utils.Memory.PrivateString"/>
            </summary>
            <returns>The new <see cref="T:VNLib.Utils.Memory.PrivateString"/> instance</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.Free">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateString.Erase">
            <summary>
            Erases the contents of the internal CLR string
            </summary>
        </member>
        <member name="T:VNLib.Utils.Memory.PrivateStringManager">
            <summary>
            When inherited by a class, provides a safe string storage that zeros a CLR string memory on disposal
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.PrivateStringManager.ProtectedElements">
            <summary>
            Strings to be cleared when exiting
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.PrivateStringManager.Item(System.Int32)">
            <summary>
            Gets or sets a string referrence into the protected elements store
            </summary>
            <param name="index"></param>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <returns>Referrence to string associated with the index</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateStringManager.#ctor(System.Int32)">
            <summary>
            Create a new instance with fixed array size
            </summary>
            <param name="elements">Number of elements to protect</param>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateStringManager.Free">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.PrivateStringManager.Clone">
            <summary>
            Creates a deep copy for a new independent <see cref="T:VNLib.Utils.Memory.PrivateStringManager"/> 
            </summary>
            <returns>A new independent <see cref="T:VNLib.Utils.Memory.PrivateStringManager"/> instance</returns>
            <remarks>Be careful duplicating large instances, and make sure clones are properly disposed if necessary</remarks>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:VNLib.Utils.Memory.ProcessHeap">
            <summary>
            Provides a <see cref="T:VNLib.Utils.Memory.IUnmangedHeap"/> wrapper for the <see cref="T:System.Runtime.InteropServices.Marshal"/> virtualalloc 
            global heap methods
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.ProcessHeap.#ctor">
            <summary>
            Initalizes a new global (cross platform) process heap
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.ProcessHeap.Alloc(System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.ProcessHeap.Free(System.IntPtr@)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.ProcessHeap.Free">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.ProcessHeap.Resize(System.IntPtr@,System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="T:VNLib.Utils.Memory.RpMallocPrivateHeap">
            <summary>
            A wrapper class for cross platform RpMalloc implementation.
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.RpMallocPrivateHeap.RpMalloc(System.UInt64,System.UIntPtr,System.Boolean)">
            <summary>
            <para>
            Initializes RpMalloc for the current thread and alloctes a block of memory
            </para>
            <para>
            NOTE: RPMalloc depends on the current OS thread
            </para>
            </summary>
            <param name="elements">The number of elements to allocate</param>
            <param name="size">The number of bytes per element type (aligment)</param>
            <param name="zero">Zero the block of memory before returning</param>
            <returns>A pointer to the block, (zero if failed)</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.RpMallocPrivateHeap.RpFree(System.IntPtr@)">
            <summary>
            Freeds an <see cref="!:UnsafeThreadLockedMemoryHandle&lt;T&gt;"/> for the current thread
            </summary>
            <param name="block">The block to free</param>
        </member>
        <member name="M:VNLib.Utils.Memory.RpMallocPrivateHeap.#ctor(System.Boolean)">
            <summary>
            Initializes a new RpMalloc first class heap to allocate memory blocks from
            </summary>
            <param name="zeroAll">A global flag to zero all blocks of memory allocated</param>
        </member>
        <member name="M:VNLib.Utils.Memory.RpMallocPrivateHeap.ReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.RpMallocPrivateHeap.AllocBlock(System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.RpMallocPrivateHeap.FreeBlock(System.IntPtr)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.RpMallocPrivateHeap.ReAllocBlock(System.IntPtr,System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.SubSequence`1">
            <summary>
            Represents a subset (or window) of data within a <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/>
            </summary>
            <typeparam name="T">The unmanaged type to wrap</typeparam>
        </member>
        <member name="P:VNLib.Utils.Memory.SubSequence`1.Size">
            <summary>
            The number of elements in the current window
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.SubSequence`1.#ctor(VNLib.Utils.Memory.MemoryHandle{`0},System.UInt64,System.Int32)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.SubSequence`1"/> to the handle to get a window of the block
            </summary>
            <param name="block"></param>
            <param name="offset"></param>
            <param name="size"></param>
        </member>
        <member name="P:VNLib.Utils.Memory.SubSequence`1.Span">
            <summary>
            Gets a <see cref="T:System.Span`1"/> that is offset from the base of the handle
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.SubSequence`1.Slice(System.UInt32,System.Int32)">
            <summary>
            Slices the current sequence into a smaller <see cref="T:VNLib.Utils.Memory.SubSequence`1"/>
            </summary>
            <param name="offset">The relative offset from the current window offset</param>
            <param name="size">The size of the block</param>
            <returns>A <see cref="T:VNLib.Utils.Memory.SubSequence`1"/> of the current sequence</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.SubSequence`1.GetHashCode">
            <summary>
            Returns the signed 32-bit hashcode
            </summary>
            <returns>A signed 32-bit integer that represents the hashcode for the current instance</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.SubSequence`1.Equals(VNLib.Utils.Memory.SubSequence{`0})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.SubSequence`1.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.SubSequence`1.op_Equality(VNLib.Utils.Memory.SubSequence{`0},VNLib.Utils.Memory.SubSequence{`0})">
            <summary>
            Determines if two <see cref="T:VNLib.Utils.Memory.SubSequence`1"/> are equal
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the sequences are equal, false otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.SubSequence`1.op_Inequality(VNLib.Utils.Memory.SubSequence{`0},VNLib.Utils.Memory.SubSequence{`0})">
            <summary>
            Determines if two <see cref="T:VNLib.Utils.Memory.SubSequence`1"/> are not equal
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if the sequences are not equal, false otherwise</returns>
        </member>
        <member name="T:VNLib.Utils.Memory.SysBufferMemoryManager`1">
            <summary>
            Provides an unmanaged System.Buffers integration with zero-cost pinning. Uses <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/>
            as a memory provider which implements a <see cref="T:System.Runtime.InteropServices.SafeHandle"/>
            </summary>
            <typeparam name="T">Unmanaged memory type</typeparam>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.#ctor(VNLib.Utils.Memory.MemoryHandle{`0})">
            <summary>
            Consumes an exisitng <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/> to provide <see cref="T:VNLib.Utils.Memory.Memory"/> wrappers.
            The handle should no longer be referrenced directly
            </summary>
            <param name="existingHandle">The existing handle to consume</param>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.#ctor(VNLib.Utils.Memory.IUnmangedHeap,System.UInt64,System.Boolean)">
            <summary>
            Allocates a fized size buffer from the specified unmanaged <see cref="T:VNLib.Utils.Memory.PrivateHeap"/>
            </summary>
            <param name="heap">The heap to perform allocations from</param>
            <param name="elements">The number of elements to allocate</param>
            <param name="zero">Zero allocations</param>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.GetSpan">
            <inheritdoc/>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.Pin(System.Int32)">
            <summary>
            <inheritdoc/>
            </summary> 
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.Unpin">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.Resize(System.UInt64)">
            <summary>
            Resizes the block of memory on the current heap
            </summary>
            <param name="elements">The number of elements</param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.SysBufferMemoryManager`1.Resize(System.Int64)">
            <summary>
            Resizes the block of memory on the current heap
            </summary>
            <param name="elements">The number of elements</param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="T:VNLib.Utils.Memory.UnmanagedHeapBase">
            <summary>
            Provides a synchronized base methods for accessing unmanaged memory. Implements <see cref="T:System.Runtime.InteropServices.SafeHandle"/>
            for safe disposal of heaps
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.UnmanagedHeapBase.HeapLock">
            <summary>
            The heap synchronization handle
            </summary>
        </member>
        <member name="F:VNLib.Utils.Memory.UnmanagedHeapBase.GlobalZero">
            <summary>
            The global heap zero flag
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initalizes the unmanaged heap base class (init synchronization handle)
            </summary>
            <param name="globalZero">A global flag to zero all blocks of memory during allocation</param>
            <param name="ownsHandle">A flag that indicates if the handle is owned by the instance</param>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.Alloc(System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
            <remarks>Increments the handle count</remarks>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.Free(System.IntPtr@)">
            <inheritdoc/>
            <remarks>Decrements the handle count</remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.Resize(System.IntPtr@,System.UInt64,System.UInt64,System.Boolean)">
            <inheritdoc/>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.ReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.AllocBlock(System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Allocates a block of memory from the heap
            </summary>
            <param name="elements">The number of elements within the block</param>
            <param name="size">The size of the element type (in bytes)</param>
            <param name="zero">A flag to zero the allocated block</param>
            <returns>A pointer to the allocated block</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.FreeBlock(System.IntPtr)">
            <summary>
            Frees a previously allocated block of memory
            </summary>
            <param name="block">The block to free</param>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.ReAllocBlock(System.IntPtr,System.UInt64,System.UInt64,System.Boolean)">
            <summary>
            Resizes the previously allocated block of memory on the current heap
            </summary>
            <param name="block">The prevously allocated block</param>
            <param name="elements">The new number of elements within the block</param>
            <param name="size">The size of the element type (in bytes)</param>
            <param name="zero">A flag to indicate if the new region of the block should be zeroed</param>
            <returns>A pointer to the same block, but resized, null if the allocation falied</returns>
            <remarks>
            Heap base relies on the block pointer to remain unchanged if the resize fails so the
            block is still valid, and the return value is used to determine if the resize was successful
            </remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.UnmanagedHeapBase.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.UnsafeMemoryHandle`1">
            <summary>
            Represents an unsafe handle to managed/unmanaged memory that should be used cautiously
            </summary>
            <typeparam name="T">Unmanaged memory type</typeparam>
        </member>
        <member name="P:VNLib.Utils.Memory.UnsafeMemoryHandle`1.Span">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.Memory.UnsafeMemoryHandle`1.IntLength">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.Memory.UnsafeMemoryHandle`1.Length">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Inializes a new <see cref="T:VNLib.Utils.Memory.UnsafeMemoryHandle`1"/> using the default
            <see cref="T:System.Buffers.ArrayPool`1"/>
            </summary>
            <param name="elements">The number of elements to store</param>
            <param name="zero">Zero initial contents?</param>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.#ctor">
            <summary>
            Creates an empty <see cref="T:VNLib.Utils.Memory.UnsafeMemoryHandle`1"/>
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.#ctor(System.Buffers.ArrayPool{`0},System.Int32,System.Boolean)">
            <summary>
            Inializes a new <see cref="T:VNLib.Utils.Memory.UnsafeMemoryHandle`1"/> using the specified
            <see cref="T:System.Buffers.ArrayPool`1"/> or RPMalloc if the native library is loaded
            </summary>
            <param name="elements">The number of elements to store</param>
            <param name="zero">Zero initial contents?</param>
            <param name="pool">The explicit pool to alloc buffers from</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.#ctor(VNLib.Utils.Memory.IUnmangedHeap,System.IntPtr,System.Int32)">
            <summary>
            Intializes a new <see cref="T:VNLib.Utils.Memory.UnsafeMemoryHandle`1"/> for an <see cref="T:VNLib.Utils.Memory.IUnmangedHeap"/>
            </summary>
            <param name="heap">The heap the initial memory block belongs to</param>
            <param name="initial">A pointer to the unmanaged memory block</param>
            <param name="elements">The number of elements this block points to</param>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.Dispose">
            <summary>
            Releases memory back to the pool or heap from which is was allocated.
            </summary>
            <remarks>After this method is called, this handle points to invalid memory</remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.Pin(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.Unpin">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.Equals(VNLib.Utils.Memory.UnsafeMemoryHandle{`0})">
            <summary>
            Determines if the other handle represents the same memory block as the 
            current handle. 
            </summary>
            <param name="other">The other handle to test</param>
            <returns>True if the other handle points to the same block of memory as the current handle</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.Equals(System.Object)">
            <summary>
            Override for object equality operator, will cause boxing
            for structures
            </summary>
            <param name="obj">The other object to compare</param>
            <returns>
            True if the passed object is of type <see cref="T:VNLib.Utils.Memory.UnsafeMemoryHandle`1"/> 
            and uses the structure equality operator
            false otherwise.
            </returns>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.op_Implicit(VNLib.Utils.Memory.UnsafeMemoryHandle{`0})~System.Span{`0}">
            <summary>
            Casts the handle to it's <see cref="T:System.Span`1"/> representation
            </summary>
            <param name="handle">the handle to cast</param>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.op_Equality(VNLib.Utils.Memory.UnsafeMemoryHandle{`0},VNLib.Utils.Memory.UnsafeMemoryHandle{`0})">
            <summary>
            Equality overload
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if handles are equal, flase otherwise</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.UnsafeMemoryHandle`1.op_Inequality(VNLib.Utils.Memory.UnsafeMemoryHandle{`0},VNLib.Utils.Memory.UnsafeMemoryHandle{`0})">
            <summary>
            Equality overload
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns>True if handles are equal, flase otherwise</returns>
        </member>
        <member name="T:VNLib.Utils.Memory.VnBufferWriter`1">
            <summary>
            Provides a stack based buffer writer
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnBufferWriter`1.Buffer">
            <summary>
            The buffer for writing output data to
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnBufferWriter`1.Written">
            <summary>
            The number of characters written to the buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnBufferWriter`1.Remaining">
            <summary>
            The number of characters remaining in the buffer
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.VnBufferWriter`1.#ctor(System.Span{`0}@)">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.VnBufferWriter`1"/> assigning the specified buffer
            </summary>
            <param name="buffer">The buffer to write data to</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnBufferWriter`1.ToString">
            <summary>
            Returns a compiled string from the characters written to the buffer
            </summary>
            <returns>A string of the characters written to the buffer</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.VnBufferWriter`1.Append(System.ReadOnlySpan{`0})">
            <summary>
            Appends a sequence  to the buffer
            </summary>
            <param name="data">The data to append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnBufferWriter`1.Append(`0)">
            <summary>
            Appends a single item to the buffer
            </summary>
            <param name="c">The item to append to the buffer</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnBufferWriter`1.Reset">
            <summary>
            Resets the writer by setting the <see cref="P:VNLib.Utils.Memory.VnBufferWriter`1.Written"/> 
            property to 0.
            </summary>
        </member>
        <member name="T:VNLib.Utils.Memory.VnList`1">
            <summary>
            Provides an <see cref="T:System.Collections.IList"/> - dynamic list - implementation using CLR managed memory
            from the <see cref="T:System.Buffers.ArrayPool`1"/> API.
            </summary>
            <typeparam name="T">The item type</typeparam>
            <remarks>Implements the <see cref="T:VNLib.Utils.Memory.Caching.IReusable"/> cache interface</remarks>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.#ctor">
            <summary>
            Initializes a new list, with an underlying buffer intialized to 100 elements
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.#ctor(System.Int32)">
            <summary>
            Initializes a new list, with the specified buffer size
            </summary>
            <param name="ssize">The initial buffer size</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.#ctor(`0[])">
            <summary>
            Initializes a new list, with the elements of specified array. The buffer size is initialized to the exact size of the specified array
            </summary>
            <param name="items">Initial items to store within the list</param>
        </member>
        <member name="P:VNLib.Utils.Memory.VnList`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.Memory.VnList`1.Count">
            <inheritdoc/>
        </member>
        <member name="P:VNLib.Utils.Memory.VnList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Add(`0)">
            <summary>
            Adds the specified item to the end of the list. Resizing/allocations may be performed
            </summary>
            <param name="item">The item to insert at the end of the list</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.AddRange(`0[])">
            <summary>
            Adds an array of items to the list
            </summary>
            <param name="items">Array of items to add to the list</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.AddRange(System.ReadOnlySpan{`0})">
            <summary>
            Adds a range items within a span to the end of the list
            </summary>
            <param name="items">Span of items to add to the list</param>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.AsSpan">
            <summary>
            Returns a span over the data within the list
            </summary>
            <returns>The span over the internal data</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Push(`0)">
            <summary>
            Equivalent to <see cref="M:VNLib.Utils.Memory.VnList`1.Add(`0)"/>. Exists for semantic reasons
            </summary>
            <param name="item">Item to add to end of the list</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Pop">
            <summary>
            Removes and item from the end of the list.
            </summary>
            <returns>The item removed from the end of the list, or default if no element exists at the end of the array</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Peek">
            <summary>
            Gets the last item in the list without removing it
            </summary>
            <returns>The last item in the list, or default if the list is empty</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Clear">
            <summary>
            <inheritdoc/>
            <br></br>
            <br></br>
            This method does not free the internal memory buffer, until the instance is disposed
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Contains(`0)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.UnsafeGetBuffer">
            <summary>
            Returns the underlying buffer used to store data. WARNING: This returns a referrence to the 
            underlying internal data buffer. Only use this method if you know what you are doing!
            </summary>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.UnsafeGetSpan">
            <summary>
            Gets a <see cref="T:System.Span`1"/> over the active data within the underlying buffer. Modifications
            this structure will affect the state of the items within the buffer.
            </summary>
            <returns>A span over the elements within the buffer</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.ToArray">
            <summary>
            Copies the content of the internal list to a new array and returns it. The list remains unmodified
            </summary>
            <returns>The array representation of the internal list</returns>
        </member>
        <member name="M:VNLib.Utils.Memory.VnList`1.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.VnString">
            <summary>
            Provides an immutable character buffer stored on an unmanged heap. Contains handles to unmanged memory, and should be disposed
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnString.Length">
            <summary>
            The number of unicode characters the current instance can reference
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnString.IsEmpty">
            <summary>
            Gets a value indicating if the current instance is empty
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.#ctor">
            <summary>
            Creates and empty <see cref="T:VNLib.Utils.Memory.VnString"/>, not particularly usefull, just and empty instance.
            </summary>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.#ctor(System.ReadOnlySpan{System.Char})">
            <summary>
            Creates a new <see cref="T:VNLib.Utils.Memory.VnString"/> around a <see cref="T:System.ReadOnlySpan`1"/> or a <see cref="T:System.String"/> of data
            </summary>
            <param name="data"><see cref="T:System.ReadOnlySpan`1"/> of data to replicate</param>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.FromStream(System.IO.Stream,System.Text.Encoding,System.UInt32)">
            <summary>
            Allocates a temporary buffer to read data from the stream until the end of the stream is reached.
            Decodes data from the user-specified encoding
            </summary>
            <param name="stream">Active stream of data to decode to a string</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to use for decoding</param>
            <param name="bufferSize">The size of the buffer to allocate during copying</param>
            <returns>The new <see cref="T:VNLib.Utils.Memory.VnString"/> instance</returns>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.OverflowException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.ConsumeHandle(VNLib.Utils.Memory.MemoryHandle{System.Char},System.UInt64,System.Int32)">
            <summary>
            Creates a new Vnstring from the <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/> buffer provided. This function "consumes"
            a handle, meaning it now takes ownsership of the the memory it points to.
            </summary>
            <param name="handle">The <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/> to consume</param>
            <param name="start">The offset from the begining of the buffer marking the begining of the string</param>
            <param name="length">The number of characters this string points to</param>
            <returns>The new <see cref="T:VNLib.Utils.Memory.VnString"/></returns>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.FromStreamAsync(System.IO.Stream,System.Text.Encoding,VNLib.Utils.Memory.IUnmangedHeap,System.Int32)">
            <summary>
            Asynchronously reads data from the specified stream and uses the specified encoding 
            to decode the binary data to a new <see cref="T:VNLib.Utils.Memory.VnString"/> heap character buffer.
            </summary>
            <param name="stream">The stream to read data from</param>
            <param name="encoding">The encoding to use while decoding data</param>
            <param name="heap">The <see cref="T:VNLib.Utils.Memory.IUnmangedHeap"/> to allocate buffers from</param>
            <param name="bufferSize">The size of the buffer to allocate</param>
            <returns>The new <see cref="T:VNLib.Utils.Memory.VnString"/> containing the data</returns>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.CharAt(System.Int32)">
            <summary>
            Gets the value of the character at the specified index
            </summary>
            <param name="index">The index of the character to get</param>
            <returns>The <see cref="T:System.Char"/> at the specified index within the buffer</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Substring(System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:VNLib.Utils.Memory.VnString"/> that is a window within the current string,
            the referrence points to the same memory as the first instnace.
            </summary>
            <param name="start">The index within the current string to begin the child string</param>
            <param name="count">The number of characters (or length) of the child string</param>
            <returns>The child <see cref="T:VNLib.Utils.Memory.VnString"/></returns>
            <remarks>
            Making substrings will reference the parents's underlying <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/>
            and all children will be set in a disposed state when the parent instance is disposed
            </remarks>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Substring(System.Int32)">
            <summary>
            Creates a <see cref="T:VNLib.Utils.Memory.VnString"/> that is a window within the current string,
            the referrence points to the same memory as the first instnace.
            </summary>
            <param name="start">The index within the current string to begin the child string</param>
            <returns>The child <see cref="T:VNLib.Utils.Memory.VnString"/></returns>
            <remarks>
            Making substrings will reference the parents's underlying <see cref="T:VNLib.Utils.Memory.MemoryHandle`1"/>
            and all children will be set in a disposed state when the parent instance is disposed
            </remarks>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.AsSpan">
            <summary>
            Gets a <see cref="T:System.ReadOnlySpan`1"/> over the internal character buffer
            </summary>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.ToString">
            <summary>
            Gets a <see cref="T:System.String"/> copy of the internal buffer
            </summary>
            <returns><see cref="T:System.String"/> representation of internal data</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.VnString.Item(System.Int32)">
            <summary>
            Gets the value of the character at the specified index
            </summary>
            <param name="index">The index of the character to get</param>
            <returns>The <see cref="T:System.Char"/> at the specified index within the buffer</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Equals(VNLib.Utils.Memory.VnString)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Equals(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Equals(System.Char[])">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Equals(System.ReadOnlySpan{System.Char})">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.CompareTo(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.CompareTo(VNLib.Utils.Memory.VnString)">
            <inheritdoc/>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.GetHashCode">
            <summary>
            Gets a hashcode for the underyling string by using the .NET <see cref="M:System.String.GetHashCode"/>
            method on the character representation of the data
            </summary>
            <returns></returns>
            <remarks>
            It is safe to compare hashcodes of <see cref="T:VNLib.Utils.Memory.VnString"/> to the <see cref="T:System.String"/> class or 
            a character span etc
            </remarks>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnString.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.VnTable`1">
            <summary>
            Provides a Row-Major ordered table for use of storing value-types in umnaged heap memory
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTable`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new 2 dimensional table in unmanaged heap memory, using the <see cref="P:VNLib.Utils.Memory.Memory.Shared"/> heap.
            User should dispose of the table when no longer in use
            </summary>
            <param name="rows">Number of rows in the table</param>
            <param name="cols">Number of columns in the table</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTable`1.#ctor(VNLib.Utils.Memory.IUnmangedHeap,System.Int32,System.Int32)">
            <summary>
            Creates a new 2 dimensional table in unmanaged heap memory, using the specified heap.
            User should dispose of the table when no longer in use
            </summary>
            <param name="heap"><see cref="T:VNLib.Utils.Memory.PrivateHeap"/> to allocate table memory from</param>
            <param name="rows">Number of rows in the table</param>
            <param name="cols">Number of columns in the table</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTable`1.Get(System.Int32,System.Int32)">
            <summary>
            Gets the value of an item in the table at the given indexes
            </summary>
            <param name="row">Row address of the item</param>
            <param name="col">Column address of item</param>
            <returns>The value of the item</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTable`1.Set(`0,System.Int32,System.Int32)">
            <summary>
            Sets the value of an item in the table at the given address
            </summary>
            <param name="item">Value of item to store</param>
            <param name="row">Row address of the item</param>
            <param name="col">Column address of item</param>
            <returns>The value of the item</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTable`1.Item(System.Int32,System.Int32)">
            <summary>
            Equivalent to <see cref="M:VNLib.Utils.Memory.VnTable`1.Get(System.Int32,System.Int32)"/> and <see cref="M:VNLib.Utils.Memory.VnTable`1.Set(`0,System.Int32,System.Int32)"/>
            </summary>
            <param name="row">Row address of item</param>
            <param name="col">Column address of item</param>
            <returns>The value of the item</returns>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTable`1.Item(System.UInt32)">
            <summary>
            Allows for direct addressing in the table. 
            </summary>
            <param name="index"></param>
            <returns></returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTable`1.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.Memory.VnTempBuffer`1">
            <summary>
            A disposable temporary buffer from shared ArrayPool
            </summary>
            <typeparam name="T">Type of buffer to create</typeparam>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTempBuffer`1.Buffer">
            <summary>
            Referrence to internal buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTempBuffer`1.InitSize">
            <summary>
            Inital/desired size of internal buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTempBuffer`1.Length">
            <summary>
            Actual length of internal buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTempBuffer`1.IntLength">
            <summary>
            Actual length of internal buffer
            </summary>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTempBuffer`1.Span">
            <inheritdoc/>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTempBuffer`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            Allocates a new <see cref="T:VNLib.Utils.Memory.VnTempBuffer`1"/> with a new buffer from shared array-pool
            </summary>
            <param name="minSize">Minimum size of the buffer</param>
            <param name="zero">Set the zero memory flag on close</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTempBuffer`1.#ctor(System.Buffers.ArrayPool{`0},System.Int32,System.Boolean)">
            <summary>
            Allocates a new <see cref="T:VNLib.Utils.Memory.VnTempBuffer`1"/> with a new buffer from specified array-pool
            </summary>
            <param name="pool">The <see cref="T:System.Buffers.ArrayPool`1"/> to allocate from and return to</param>
            <param name="minSize">Minimum size of the buffer</param>
            <param name="zero">Set the zero memory flag on close</param>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTempBuffer`1.GetOffsetWrapper(System.Int32,System.Int32)">
            <summary>
            Gets an offset wrapper around the current buffer
            </summary>
            <param name="offset">Offset from begining of current buffer</param>
            <param name="count">Number of <typeparamref name="T"/> from offset</param>
            <returns>An <see cref="T:System.ArraySegment`1"/> wrapper around the current buffer containing the offset</returns>
        </member>
        <member name="P:VNLib.Utils.Memory.VnTempBuffer`1.Item(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTempBuffer`1.AsMemory">
            <summary>
            Gets a memory structure around the internal buffer
            </summary>
            <returns>A memory structure over the buffer</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTempBuffer`1.AsMemory(System.Int32,System.Int32)">
            <summary>
            Gets a memory structure around the internal buffer
            </summary>
            <param name="count">The number of elements included in the result</param>
            <param name="start">A value specifying the begining index of the buffer to include</param>
            <returns>A memory structure over the buffer</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTempBuffer`1.AsMemory(System.Int32)">
            <summary>
            Gets a memory structure around the internal buffer
            </summary>
            <param name="count">The number of elements included in the result</param>
            <returns>A memory structure over the buffer</returns>
            <exception cref="T:System.ObjectDisposedException"></exception>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:VNLib.Utils.Memory.VnTempBuffer`1.Free">
            <summary>
            Returns buffer to shared array-pool
            </summary>
        </member>
        <member name="T:VNLib.Utils.OpenHandle">
            <summary>
            Represents a base class for an open resource or operation that is valid while being held, 
            and is released or unwound when disposed.
            </summary>
            <remarks>
            The <see cref="T:VNLib.Utils.OpenHandle"/> pattern, may throw exceptions when disposed as deferred 
            release actions are completed
            </remarks>
        </member>
        <member name="T:VNLib.Utils.OpenResourceHandle`1">
            <summary>
            <para>
            An abstract base class for an <see cref="T:VNLib.Utils.OpenHandle"/> that holds a specific resource and manages its lifetime.
            </para>
            </summary>
            <inheritdoc/>
            <typeparam name="TResource">The resource type</typeparam>
        </member>
        <member name="P:VNLib.Utils.OpenResourceHandle`1.Resource">
            <summary>
            The resource held by the open handle
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="T:VNLib.Utils.ResourceDeleteFailedException">
            <summary>
            Raised when a resource delete has failed
            </summary>
        </member>
        <member name="T:VNLib.Utils.ResourceUpdateFailedException">
            <summary>
            Raised when a resource update has failed
            </summary>
        </member>
        <member name="T:VNLib.Utils.SafeLibraryHandle">
            <summary>
            Represents a safe handle to a native library loaded to the current process
            </summary>
        </member>
        <member name="P:VNLib.Utils.SafeLibraryHandle.IsInvalid">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.SafeLibraryHandle.LoadLibrary(System.String,System.Runtime.InteropServices.DllImportSearchPath)">
            <summary>
            Finds and loads the specified native libary into the current process by its name at runtime 
            </summary>
            <param name="libPath">The path (or name of libary) to search for</param>
            <param name="searchPath">
            The <see cref="T:System.Runtime.InteropServices.DllImportSearchPath"/> used to search for libaries 
            within the current filesystem
            </param>
            <returns>The loaded <see cref="T:VNLib.Utils.SafeLibraryHandle"/></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.DllNotFoundException"></exception>
        </member>
        <member name="M:VNLib.Utils.SafeLibraryHandle.TryLoadLibrary(System.String,System.Runtime.InteropServices.DllImportSearchPath,VNLib.Utils.SafeLibraryHandle@)">
             <summary>
             Attempts to load the specified native libary into the current process by its name at runtime 
             </summary>
            <param name="libPath">The path (or name of libary) to search for</param>
             <param name="searchPath">
             The <see cref="T:System.Runtime.InteropServices.DllImportSearchPath"/> used to search for libaries 
             within the current filesystem
             </param>
             <param name="lib">The handle to the libary if successfully loaded</param>
             <returns>True if the libary was found and loaded into the current process</returns>
        </member>
        <member name="M:VNLib.Utils.SafeLibraryHandle.GetMethod``1(System.String)">
            <summary>
            Loads a native method from the library of the specified name and managed delegate
            </summary>
            <typeparam name="T">The native method delegate type</typeparam>
            <param name="methodName">The name of the native method</param>
            <returns>A wapper handle around the native method delegate</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ObjectDisposedException">If the handle is closed or invalid</exception>
            <exception cref="T:System.EntryPointNotFoundException">When the specified entrypoint could not be found</exception>
        </member>
        <member name="M:VNLib.Utils.SafeLibraryHandle.DangerousGetMethod``1(System.String)">
            <summary>
            Gets an delegate wrapper for the specified method without tracking its referrence.
            The caller must manage the <see cref="T:VNLib.Utils.SafeLibraryHandle"/> referrence count in order
            to not leak resources or cause process corruption
            </summary>
            <typeparam name="T">The native method delegate type</typeparam>
            <param name="methodName">The name of the native method</param>
            <returns>A the delegate wrapper on the native method</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ObjectDisposedException">If the handle is closed or invalid</exception>
            <exception cref="T:System.EntryPointNotFoundException">When the specified entrypoint could not be found</exception>
        </member>
        <member name="M:VNLib.Utils.SafeLibraryHandle.ReleaseHandle">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.SafeMethodHandle`1">
            <summary>
            Represents a handle to a <see cref="T:VNLib.Utils.SafeLibraryHandle"/>'s 
            native method
            </summary>
            <typeparam name="T">The native method deelgate type</typeparam>
        </member>
        <member name="P:VNLib.Utils.SafeMethodHandle`1.Method">
            <summary>
            A delegate to the native method
            </summary>
        </member>
        <member name="M:VNLib.Utils.SafeMethodHandle`1.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.UpdateCallback">
            <summary>
            A callback delegate used for updating a <see cref="T:VNLib.Utils.UpdatableResource"/>
            </summary>
            <param name="source">The <see cref="T:VNLib.Utils.UpdatableResource"/> to be updated</param>
            <param name="data">The serialized data to be stored/updated</param>
            <exception cref="T:VNLib.Utils.ResourceUpdateFailedException"></exception>
        </member>
        <member name="T:VNLib.Utils.DeleteCallback">
            <summary>
            A callback delegate invoked when a <see cref="T:VNLib.Utils.UpdatableResource"/> delete is requested
            </summary>
            <param name="source">The <see cref="T:VNLib.Utils.UpdatableResource"/> to be deleted</param>
            <exception cref="T:VNLib.Utils.ResourceDeleteFailedException"></exception>
        </member>
        <member name="T:VNLib.Utils.UpdatableResource">
            <summary>
            Implemented by a resource that is backed by an external data store, that when modified or deleted will 
            be reflected to the backing store.
            </summary>
        </member>
        <member name="F:VNLib.Utils.UpdatableResource.Deleted">
            <summary>
            A value indicating whether the instance should be deleted when released
            </summary>
        </member>
        <member name="F:VNLib.Utils.UpdatableResource.Modified">
            <summary>
            A value indicating whether the instance should be updated when released
            </summary>
        </member>
        <member name="M:VNLib.Utils.UpdatableResource.Check">
            <summary>
            Checks if the resouce has been disposed and raises an exception if it is
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="P:VNLib.Utils.UpdatableResource.IsReleased">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.UpdatableResource.Initialize(VNLib.Utils.UpdateCallback,VNLib.Utils.DeleteCallback,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Inializes the callback functions and serializer options to use when serialzing the state data
            </summary>
            <param name="updateCallback">The function to invoke when the resource has been modified and need to be updated</param>
            <param name="deletedCallback">The function to invoke when the resource should be deleted</param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> to use when serializing resource</param>
        </member>
        <member name="M:VNLib.Utils.UpdatableResource.Release">
            <summary>
            <inheritdoc/>
            </summary>
            <exception cref="T:System.InvalidOperationException"></exception>
            <exception cref="T:VNLib.Utils.ResourceDeleteFailedException"></exception>
            <exception cref="T:VNLib.Utils.ResourceUpdateFailedException"></exception>
        </member>
        <member name="M:VNLib.Utils.UpdatableResource.FlushPendingChanges">
            <summary>
            Writes the current state of the the resource to the backing store
            immediatly by invoking the specified callback. 
            <br></br>
            <br></br>
            Only call this method if your store supports multiple state updates
            </summary>
        </member>
        <member name="M:VNLib.Utils.UpdatableResource.Delete">
            <summary>
            Marks the resource for deletion from backing store during closing events
            </summary>
        </member>
        <member name="M:VNLib.Utils.UpdatableResource.GetResource">
            <summary>
            Returns the JSON serializable resource to be updated during an update
            </summary>
            <returns>The resource to update</returns>
        </member>
        <member name="M:VNLib.Utils.UpdatableResource.Free">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.VnDisposeable">
            <summary>
            Provides a base class with abstract methods for for disposable objects, with disposed check method
            </summary>
        </member>
        <member name="P:VNLib.Utils.VnDisposeable.Disposed">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.VnDisposeable.Free">
            <summary>
            When overriden in a child class, is responsible for freeing resources
            </summary>
        </member>
        <member name="M:VNLib.Utils.VnDisposeable.Check">
            <summary>
            Checks if the current object has been disposed. Method will be inlined where possible
            </summary>
            <exception cref="T:System.ObjectDisposedException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnDisposeable.SetDisposedState">
            <summary>
            Sets the internal state to diposed without calling <see cref="M:VNLib.Utils.VnDisposeable.Free"/> operation.
            Usefull if another code-path performs the free operation independant of a dispose opreation.
            </summary>
        </member>
        <member name="M:VNLib.Utils.VnDisposeable.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:VNLib.Utils.VnDisposeable.Dispose">
            <inheritdoc/>
        </member>
        <member name="T:VNLib.Utils.VnEncoding">
            <summary>
            Contains static methods for encoding data
            </summary>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.GetMemoryStream(System.ReadOnlySpan{System.Char}@,System.Text.Encoding)">
            <summary>
            Encodes a <see cref="T:System.ReadOnlySpan`1"/> with the specified <see cref="T:System.Text.Encoding"/> to a <see cref="T:VNLib.Utils.IO.VnMemoryStream"/> that must be disposed by the user
            </summary>
            <param name="data">Data to be encoded</param>
            <param name="encoding"><see cref="T:System.Text.Encoding"/> to encode data with</param>
            <returns>A <see cref="T:System.IO.Stream"/> contating the encoded data</returns>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.JSONDeserializeFromBinary``1(System.IO.Stream,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Attempts to deserialze a json object from a stream of UTF8 data
            </summary>
            <typeparam name="T">The type of the object to deserialize</typeparam>
            <param name="data">Binary data to read from</param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> object to pass to deserializer</param>
            <returns>The object decoded from the stream</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.JSONDeserializeFromBinary(System.IO.Stream,System.Type,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Attempts to deserialze a json object from a stream of UTF8 data
            </summary>
            <param name="data">Binary data to read from</param>
            <param name="type"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> object to pass to deserializer</param>
            <returns>The object decoded from the stream</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.JSONDeserializeFromBinaryAsync``1(System.IO.Stream,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Attempts to deserialze a json object from a stream of UTF8 data
            </summary>
            <typeparam name="T">The type of the object to deserialize</typeparam>
            <param name="data">Binary data to read from</param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> object to pass to deserializer</param>
            <param name="cancellationToken"></param>
            <returns>The object decoded from the stream</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.JSONDeserializeFromBinaryAsync(System.IO.Stream,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)">
            <summary>
            Attempts to deserialze a json object from a stream of UTF8 data
            </summary>
            <param name="data">Binary data to read from</param>
            <param name="type"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> object to pass to deserializer</param>
            <param name="cancellationToken"></param>
            <returns>The object decoded from the stream</returns>
            <exception cref="T:System.Text.Json.JsonException"></exception>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.JSONSerializeToBinary``1(``0,System.IO.Stream,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Attempts to serialize the object to json and write the encoded data to the stream
            </summary>
            <typeparam name="T">The object type to serialize</typeparam>
            <param name="data">The object to serialize</param>
            <param name="output">The <see cref="T:System.IO.Stream"/> to write output data to</param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> object to pass to serializer</param>
            <exception cref="T:System.Text.Json.JsonException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.JSONSerializeToBinary(System.Object,System.IO.Stream,System.Type,System.Text.Json.JsonSerializerOptions)">
            <summary>
            Attempts to serialize the object to json and write the encoded data to the stream
            </summary>
            <param name="data">The object to serialize</param>
            <param name="output">The <see cref="T:System.IO.Stream"/> to write output data to</param>
            <param name="type"></param>
            <param name="options"><see cref="T:System.Text.Json.JsonSerializerOptions"/> object to pass to serializer</param>
            <exception cref="T:System.Text.Json.JsonException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.TryToBase32Chars(System.ReadOnlySpan{System.Byte},System.Span{System.Char})">
            <summary>
            Attempts to convert the specified byte sequence in Base32 encoding 
            and writing the encoded data to the output buffer.
            </summary>
            <param name="input">The input buffer to convert</param>
            <param name="output">The ouput buffer to write encoded data to</param>
            <returns>The number of characters written, false if no data was written or output buffer was too small</returns>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.TryToBase32Chars(System.ReadOnlySpan{System.Byte},VNLib.Utils.Memory.VnBufferWriter{System.Char}@)">
            <summary>
            Attempts to convert the specified byte sequence in Base32 encoding 
            and writing the encoded data to the output buffer.
            </summary>
            <param name="input">The input buffer to convert</param>
            <param name="writer">A <see cref="T:VNLib.Utils.Memory.VnBufferWriter`1"/> to write encoded chars to</param>
            <returns>The number of characters written, false if no data was written or output buffer was too small</returns>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.TryFromBase32Chars(System.ReadOnlySpan{System.Char},System.Span{System.Byte})">
            <summary>
            Attempts to decode the Base32 encoded string
            </summary>
            <param name="input">The Base32 encoded data to decode</param>
            <param name="output">The output buffer to write decoded data to</param>
            <returns>The number of bytes written to the output</returns>
            <exception cref="T:System.FormatException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.TryFromBase32Chars(System.ReadOnlySpan{System.Char},VNLib.Utils.Memory.VnBufferWriter{System.Byte}@)">
            <summary>
            Attempts to decode the Base32 encoded string
            </summary>
            <param name="input">The Base32 encoded data to decode</param>
            <param name="writer">A <see cref="T:VNLib.Utils.Memory.VnBufferWriter`1"/> to write decoded bytes to</param>
            <returns>The number of bytes written to the output</returns>
            <exception cref="T:System.FormatException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.Base32CalcMaxBufferSize(System.Int32)">
            <summary>
            Calculates the maximum buffer size required to encode a binary block to its Base32
            character encoding
            </summary>
            <param name="bufferSize">The binary buffer size used to calculate the base32 buffer size</param>
            <returns>The maximum size (including padding) of the character buffer required to encode the binary data</returns>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.ToBase32String(System.ReadOnlySpan{System.Byte},System.Boolean)">
            <summary>
            Converts the binary buffer to a base32 character string with optional padding characters
            </summary>
            <param name="binBuffer">The buffer to encode</param>
            <param name="withPadding">Should padding be included in the result</param>
            <returns>The base32 encoded string representation of the specified buffer</returns>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.FromBase32String``1(System.ReadOnlySpan{System.Char})">
            <summary>
            Converts the base32 character buffer to its structure representation
            </summary>
            <typeparam name="T">The structure type</typeparam>
            <param name="base32">The base32 character buffer</param>
            <returns>The new structure of the base32 data</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.FromBase32String(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets a byte array of the base32 decoded data
            </summary>
            <param name="base32">The character array to decode</param>
            <returns>The byte[] of the decoded binary data, or null if the supplied character array was empty</returns>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.ToBase32String``1(``0,System.Boolean)">
            <summary>
            Converts a structure to its base32 representation and returns the string of its value
            </summary>
            <typeparam name="T">The structure type</typeparam>
            <param name="value">The structure to encode</param>
            <param name="withPadding">A value indicating if padding should be used</param>
            <returns>The base32 string representation of the structure</returns>
            <exception cref="T:System.ArgumentException"></exception>
            <exception cref="T:System.OutOfMemoryException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.PercentEncodeCalcBufferSize(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Deterimes the size of the buffer needed to encode a utf8 encoded 
            character buffer into its url-safe percent/hex encoded representation
            </summary>
            <param name="utf8Bytes">The buffer to examine</param>
            <param name="allowedChars">A sequence of characters that are excluded from encoding</param>
            <returns>The size of the buffer required to encode</returns>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.PercentEncode(System.ReadOnlySpan{System.Byte},System.Span{System.Byte},System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Percent encodes the buffer for utf8 encoded characters to its percent/hex encoded 
            utf8 character representation
            </summary>
            <param name="utf8Bytes">The buffer of utf8 encoded characters to encode</param>
            <param name="utf8Output">The buffer to write the encoded characters to</param>
            <param name="allowedChars">A sequence of characters that are excluded from encoding</param>
            <returns>The number of characters encoded and written to the output buffer</returns>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.PercentDecode(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Decodes a percent (url/hex) encoded utf8 encoded character buffer to its utf8
            encoded binary value
            </summary>
            <param name="utf8Encoded">The buffer containg characters to be decoded</param>
            <param name="utf8Output">The buffer to write deocded values to</param>
            <returns>The nuber of bytes written to the output buffer</returns>
            <exception cref="T:System.FormatException"></exception>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.TryFromBase64Chars(System.ReadOnlySpan{System.Char},System.Span{System.Byte})">
            <summary>
            Tries to convert the specified span containing a string representation that is 
            encoded with base-64 digits into a span of 8-bit unsigned integers.
            </summary>
            <param name="base64">Base64 character data to recover</param>
            <param name="buffer">The binary output buffer to write converted characters to</param>
            <returns>The number of bytes written, or <see cref="F:VNLib.Utils.ERRNO.E_FAIL"/> of the conversion was unsucessful</returns>
        </member>
        <member name="M:VNLib.Utils.VnEncoding.TryToBase64Chars(System.ReadOnlySpan{System.Byte},System.Span{System.Char},System.Base64FormattingOptions)">
            <summary>
            Tries to convert the 8-bit unsigned integers inside the specified read-only span
            into their equivalent string representation that is encoded with base-64 digits.
            You can optionally specify whether to insert line breaks in the return value.
            </summary>
            <param name="buffer">The binary buffer to convert characters from</param>
            <param name="base64">The base64 output buffer</param>
            <param name="options">
            One of the enumeration values that specify whether to insert line breaks in the
            return value. The default value is System.Base64FormattingOptions.None.
            </param>
            <returns>The number of characters encoded, or <see cref="F:VNLib.Utils.ERRNO.E_FAIL"/> if conversion was unsuccessful</returns>
        </member>
    </members>
</doc>
